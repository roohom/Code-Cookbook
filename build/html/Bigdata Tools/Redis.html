

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>10. Redis &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="11. Spark" href="Spark.html" />
    <link rel="prev" title="9. Kylin" href="Kylin.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">大数据</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Bigdata Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Apache%20Druid.html">1. Apache Druid</a></li>
<li class="toctree-l2"><a class="reference internal" href="Apache%20Flume.html">2. Apache Flume</a></li>
<li class="toctree-l2"><a class="reference internal" href="Flink.html">3. Flink</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hadoop%E6%90%AD%E5%BB%BA%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4.html">4. Hadoop搭建总体步骤</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hbase.html">5. Hbase</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hive%E6%95%B0%E4%BB%93.html">6. Hive</a></li>
<li class="toctree-l2"><a class="reference internal" href="Kafka.html">7. Kafka</a></li>
<li class="toctree-l2"><a class="reference internal" href="Kudu.html">8. Kudu</a></li>
<li class="toctree-l2"><a class="reference internal" href="Kylin.html">9. Kylin</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10. Redis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">10.1. 介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">10.2. 应用场景</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">10.3. 特点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#windowsredis">10.4. Windows上使用Redis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">10.5. 数据类型和语法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#string">10.5.1. String</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hash">10.5.2. Hash</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list">10.5.3. List</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set">10.5.4. Set</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zset">10.5.5. Zset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">10.5.6. 通用命令</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">10.6. 持久化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rdb">10.6.1. RDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aof">10.6.2. AOF</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">10.7. 集群搭建</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">10.7.1. 模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">10.7.2. 主从复制</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sentinel">10.7.3. 哨兵模式Sentinel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">10.7.4. 集群模式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">10.8. Redis的数据分区</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">10.8.1. 虚拟槽分区</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">10.8.2. 分区的规则</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id15">10.9. 可能遇到的问题</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Spark.html">11. Spark</a></li>
<li class="toctree-l2"><a class="reference internal" href="SparkCore.html">12. Spark Core</a></li>
<li class="toctree-l2"><a class="reference internal" href="SparkSQL.html">13. Spark SQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="SparkStreaming.html">14. Spark Streaming</a></li>
<li class="toctree-l2"><a class="reference internal" href="StructuredStreaming.html">15. Structured Streaming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Zookeeper.html">16. Zookeeper</a></li>
<li class="toctree-l2"><a class="reference internal" href="ZookeeperAndHadoop.html">17. ZookeeperAndHadoop</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97.html">18. 常用软件梳理</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">博客</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Blog%20Here/index.html">Blogs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Bigdata Tools</a> &raquo;</li>
        
      <li><span class="section-number">10. </span>Redis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Bigdata Tools/Redis.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="redis">
<h1><span class="section-number">10. </span>Redis<a class="headerlink" href="#redis" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2><span class="section-number">10.1. </span>介绍<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>本质：分布式的<strong>基于内存</strong>的NoSQL<strong>数据库</strong></p>
<ul>
<li><p>数据库：用于存储数据的</p></li>
<li><p>分布式：解决了高并发和存储能力的问题</p></li>
<li><p>特点：</p>
<ul>
<li><p>基于内存</p></li>
<li><p>所有的数据都会存储在内存中，所有的读写都直接操作内存</p>
<ul>
<li><p>问题</p>
<ul>
<li><p>内存：小、易丢失</p></li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li><p>小：集群分布式构成<strong>分布式内存</strong></p></li>
<li><p>易丢失：虽然数据都在内存中，但磁盘中保留一份数据，每次重新启动都会从磁盘中将数据加载到内存</p></li>
</ul>
</li>
<li><p>问题：写入磁盘又需要提供高性能的读写，如何实现？</p>
<ul>
<li><p>数据安全和性能必须二选一</p></li>
<li><p>保证数据安全的情况的前提下提供最好的性能</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>功能：基于数据库设计，实现数据存储</p></li>
<li><p>实现：基于内存的数据存储</p></li>
<li><p>数据库分类：</p>
<ul>
<li><p>RDBMS：关系型数据库管理系统</p>
<ul>
<li><p>MySQL、Oracle、SQLServer</p></li>
<li><p>特点：</p>
<ul>
<li><p>一般都支持SQL语句</p></li>
<li><p>允许数据之间的关联</p></li>
<li><p>存储容量较小，存储数据量如果较大性能就会下降</p></li>
</ul>
</li>
<li><p>区别：性能的区别</p></li>
</ul>
</li>
<li><p>NoSQL(Not Only SQL)：非关系型数据库</p>
<ul>
<li><p>Redis、Hbase、MongoDB</p></li>
<li><p>特点：</p>
<ul>
<li><p>每种NoSQL的特点都不一样</p></li>
<li><p>为了追求小数据量高性能读写如Redis</p></li>
<li><p>为了解决大数据量的高性能读写如HBase</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><span class="section-number">10.2. </span>应用场景<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>传统的web开发</p>
<ul>
<li><p>用于实现读缓存</p>
<ul>
<li><p>传统网站架构</p>
<ul>
<li><p>同时大量的并发读写请求MySQL，而MySQL无法响应支持这种高并发的场景，导致请求失败</p></li>
</ul>
</li>
</ul>
</li>
<li><p>引入Redis</p>
<ul>
<li><p>实现读写分离，写入MySQL，将大量的高并发的<strong>读</strong>请求提交给Redis来实现</p></li>
</ul>
</li>
</ul>
</li>
<li><p>大数据的应用场景</p>
<ul>
<li><p>适合于高并发的场景</p></li>
<li><p>适合于读写性能要求非常高的场景</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><span class="section-number">10.3. </span>特点<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>分布式</p></li>
<li><p>基于内存</p></li>
<li><p>基于C语言开发，对内存的管理、编译、数据的存储更加的高效</p></li>
<li><p>支持高并发：并发量：单台机器10w/s</p></li>
<li><p>不能代替MySQL</p>
<ul>
<li><p>MySQL：支持复杂的业务，以及复杂数据存储，支持SQL，更加稳定</p></li>
<li><p>Redis：高并发高性能，存在数据丢失的隐患，存储结构比较单一，不能满足业务存储</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="windowsredis">
<h2><span class="section-number">10.4. </span>Windows上使用Redis<a class="headerlink" href="#windowsredis" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>架构</p>
<ul>
<li><p>Standalone：单节点</p></li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>启动服务端</p>
<ul>
<li><p>Redis-server.exe</p></li>
</ul>
</li>
<li><p>启动客户端</p>
<ul>
<li><p>Redis-cli.exe</p></li>
</ul>
</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li><p>KV结构：</p>
<ul>
<li><p>整个Redis中所有的数据都是以KV进行读写的</p></li>
<li><p>通过K来读写Value</p></li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li><p>K：Redis中每条数据即每个KV的K都是String类型的(<strong>永远都是String类型</strong>)</p></li>
<li><p>V：Redis的V有五种类型结构</p>
<ul>
<li><p>String：字符串类型</p></li>
<li><p>Hash：类似于Java中的Map集合</p>
<ul>
<li><p>Java：</p></li>
<li><p>Map1（K：string， map2：HashMap）</p></li>
</ul>
</li>
<li><p>List：集合类型，有序可重复集合</p></li>
<li><p>Set：集合类型，无序不可重复</p></li>
<li><p>Zset：集合类型，有序不可重复集合</p>
<ul>
<li><p>类似于Java中的TreeMap</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2><span class="section-number">10.5. </span>数据类型和语法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<div class="section" id="string">
<h3><span class="section-number">10.5.1. </span>String<a class="headerlink" href="#string" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="hash">
<h3><span class="section-number">10.5.2. </span>Hash<a class="headerlink" href="#hash" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>语法</p>
<ul>
<li><p>单个属性写入：hset</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hset</span>	<span class="n">K</span>	<span class="n">V</span><span class="p">[]</span>
</pre></div>
</div>
</li>
<li><p>单个属性读取：hget</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hget</span>	<span class="n">K</span>	<span class="n">v1</span>
</pre></div>
</div>
</li>
<li><p>批量添加：hmset</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>hmset 	K 	V[k1  v1  K2  v2 ……]
</pre></div>
</div>
</li>
<li><p>批量化读取：hmget</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hmget</span> <span class="n">K</span> <span class="n">K1</span> <span class="n">K2</span> <span class="n">K3</span>
</pre></div>
</div>
</li>
<li><p>获取所有的属性：hgetall</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hgetall</span> <span class="n">K</span>
</pre></div>
</div>
</li>
<li><p>删除Hash中的某个元素：hdel</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hdel</span>  <span class="n">K</span>  <span class="n">K1</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="list">
<h3><span class="section-number">10.5.3. </span>List<a class="headerlink" href="#list" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>应用：有序可重复的集合的数据</p>
<ul class="simple">
<li><p>类似于Java中的List</p></li>
<li><p>用于存放一系列有序变化的数据</p></li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>插入</p>
<ul>
<li><p>左序插入：lpush</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>lpush K V<span class="o">[</span>e1 e2 e3 e4<span class="o">]</span>
</pre></div>
</div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#实际存放的是</span>
K  e4 e3 e2 e1
</pre></div>
</div>
</li>
<li><p>右序插入：rpush</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rpush</span> <span class="n">K</span> <span class="n">V</span><span class="p">[</span><span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span> <span class="n">e4</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#实际存放的是</span>
K  e1 e2 e3 e4
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>读取：lrange</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lrange</span> <span class="n">K</span> <span class="n">start</span> <span class="n">end</span>
</pre></div>
</div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#左序查询：起始位置为0</span>
lrange list1  <span class="m">0</span>  <span class="m">1</span>
<span class="c1">#右序查询</span>
</pre></div>
</div>
</li>
<li><p>长度：llen</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>llen K
</pre></div>
</div>
</li>
<li><p>删除元素</p>
<ul>
<li><p>左边删除：lpop</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>lpop K
</pre></div>
</div>
</li>
<li><p>右边删除：rpop</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="set">
<h3><span class="section-number">10.5.4. </span>Set<a class="headerlink" href="#set" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>应用：无序不可重复的集合，用于去重统计等等</p>
<ul class="simple">
<li><p>类似于Java中的set集合</p></li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li><p>插入数据：sadd</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sadd</span>  <span class="n">K</span>  <span class="n">V</span><span class="p">[</span><span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>查询数据：smembers</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">smembers</span> <span class="n">K</span>
</pre></div>
</div>
</li>
<li><p>元素判断：sismember</p>
<ul>
<li><p>判断当前set元素是否是该set的成员</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sismembers</span>  <span class="n">K</span>  <span class="n">e</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>元素的移除：srem</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">srem</span>  <span class="n">K</span>  <span class="n">e</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="zset">
<h3><span class="section-number">10.5.5. </span>Zset<a class="headerlink" href="#zset" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>应用：有序不可重复的集合，一般用于排序取TopN</p></li>
<li><p>使用</p>
<ul>
<li><p>添加元素：zadd</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zadd</span>  	<span class="n">K</span>   <span class="p">[</span><span class="n">score1</span> <span class="n">V1</span> <span class="n">score2</span> <span class="n">V2</span> <span class="n">score3</span> <span class="n">V3</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>查询：zrange</p>
<ul class="simple">
<li><p>默认升序</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zrange</span>  <span class="n">K</span>   <span class="n">start</span>  <span class="n">end</span>    <span class="p">[</span><span class="n">withscores</span><span class="p">]</span>
</pre></div>
</div>
<blockquote>
<div><p>在使用Redis时，不建议存储double类型的score，因为其在底层会有精度为题</p>
<p>如果需要存储double类型，将其转换为int类型</p>
<p>写:20.01 x 100 = 2001</p>
<p>读:2001 / 100 = 20.01</p>
</div></blockquote>
</li>
<li><p>倒叙查询：zrevrange</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zrevrange</span>  <span class="n">K</span>  <span class="n">start</span>  <span class="n">end</span> <span class="p">[</span><span class="n">withscores</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>取集合长度：zcard</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zcard</span> <span class="n">K</span>
</pre></div>
</div>
</li>
<li><p>移除元素：zrem</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zrem</span>   <span class="n">K</span>   <span class="n">Vkey</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id5">
<h3><span class="section-number">10.5.6. </span>通用命令<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">*</span></code> ：列举当前数据库中的所有KV</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">del</span></code>：用于删除当前数据库中的某个KV</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">name</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">exists</span></code>：用于判断当前数据库中是否存在某个key</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">K</span></code></p></li>
</ul>
</li>
<li><p>type：用于查看某个K的类型</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">K</span></code></p></li>
</ul>
</li>
<li><p>select ：切换数据库</p></li>
<li><p>move：用于实现数据库之间key的移动</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#切换进1数据库</span>
<span class="k">select</span> <span class="m">1</span>
<span class="c1">#将数据库1中的s2移动至0数据库下</span>
move s2 <span class="m">0</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="id6">
<h2><span class="section-number">10.6. </span>持久化<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>Redis如何实现将内存中的数据写入磁盘</p>
<ul>
<li><p>RDB：默认的持久化方式</p></li>
<li><p>AOF：工作中使用</p></li>
</ul>
</li>
</ul>
<div class="section" id="rdb">
<h3><span class="section-number">10.6.1. </span>RDB<a class="headerlink" href="#rdb" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>功能：在规定时间内，内存中产生了一定次数的更新(增删改)，就会将内存中的数据做一次全量快照</p></li>
<li><p>实现：</p>
<ul>
<li><p>自动实现：配置文件决定</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">save</span>  <span class="n">时间</span>  <span class="n">数据更新的次数</span>
<span class="n">save</span>  <span class="mi">300</span>   	<span class="mi">10</span>
</pre></div>
</div>
</li>
<li><p>如果300秒内，产生了十次数据更新，就将内存中的数据全量覆盖到本地磁盘</p></li>
<li><p>配置文件中的默认规则</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">save</span>  <span class="mi">900</span>   <span class="mi">1</span>
<span class="n">save</span>  <span class="mi">300</span>   <span class="mi">10</span> 
<span class="n">save</span>  <span class="mi">60</span>    <span class="mi">10000</span>
</pre></div>
</div>
<ul>
<li><p>可以配置多组策略，热河一组达到条件，都会触发快照的生成</p></li>
<li><p>多组策略的设计目的：保证各种读写场景下的数据安全</p>
<ul class="simple">
<li><p>读多、写少：不需要频繁地构建快照，内存与文件的数据基本一致</p></li>
<li><p>写多、读少：数据更新地比较频繁，短时间内有大量数据生成，需要频繁更新</p></li>
</ul>
</li>
<li><p>快照存放的位置</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/export/server/{$Redis}/redisdata/
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>手动生成</p>
<ul class="simple">
<li><p>save：手动阻塞Redis的所有请求，将内存的数据做一次全量快照写入磁盘</p>
<ul>
<li><p>指导快照生成完成，恢复所有的读写请求</p></li>
</ul>
</li>
<li><p>bgsave：后台启动一个线程来实现快照生成，不影响读写不影响业务</p></li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul class="simple">
<li><p>优点：</p>
<ul>
<li><p>每次做的是全量快照，内存中的数据肯定和磁盘中的数据一样</p></li>
<li><p>这种快照是二进制文件，生成和读写都很快</p></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>容易产生数据丢失</p></li>
<li><p>达到了时间，但是更新次数没达到，如果机器故障，已经更新的数据就丢失了</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="aof">
<h3><span class="section-number">10.6.2. </span>AOF<a class="headerlink" href="#aof" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>设计：</p>
<ul class="simple">
<li><p>规定时间内或者指定操作做增量的同步</p>
<ul>
<li><p>每次只将内存中发生变化的数据<strong>追加写入</strong>磁盘</p></li>
</ul>
</li>
</ul>
</li>
<li><p>规则：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>appendfsync no:不进行fsync，将flush文件的实际交给OS决定，速度最快
appendfsync always:每写入一条日志就进行一次fsync操作，数据安全性最高，但是速度最慢
appendfsync everysec:折中的做法，交由后台线程每秒fsync一次，每秒将内存更新的数据同步追加到磁盘中，最多会产生1s的数据丢失
</pre></div>
</div>
</li>
<li><p>一般选用第三种方式，即appendfsync everysec</p></li>
<li><p>优缺点</p>
<ul>
<li><p>优点：数据丢失的概率或者比例变小，数据相对安全，而且保证了性能</p></li>
<li><p>缺点：</p>
<ul>
<li><p>以追加的方式，将内存中更新的数据写入普通文本文件</p>
<ul class="simple">
<li><p>相对于二进制文件，写入和读取加载都比较慢</p></li>
</ul>
</li>
<li><p>内存数据与磁盘数据不一致</p>
<ul>
<li><p>解决：定期做全量</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#如果当前的数据相对于上一次的初始文件增长了百分之百，就做一次全量</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">percentage</span> <span class="mi">100</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="nb">min</span><span class="o">-</span><span class="n">size</span> <span class="mi">64</span><span class="n">MB</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id7">
<h2><span class="section-number">10.7. </span>集群搭建<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3><span class="section-number">10.7.1. </span>模式<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>单节点</p>
<ul>
<li><p>一台机器Redis</p>
<ul>
<li><p>如果这台Redis故障，会导致整个业务不可用</p></li>
<li><p>一台机器的内存有限，无法实现大数据的实时存储</p></li>
</ul>
</li>
</ul>
</li>
<li><p>集群模式</p>
<ul>
<li><p>主从复制</p></li>
<li><p>哨兵模式</p></li>
<li><p>集群模式/分区模式</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id9">
<h3><span class="section-number">10.7.2. </span>主从复制<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>架构</p>
<ul class="simple">
<li><p>类似于Zookeeper</p></li>
<li><p>主从节点</p>
<ul>
<li><p>Master：主节点</p>
<ul>
<li><p>负责提供读写</p></li>
</ul>
</li>
<li><p>Slave：从节点</p>
<ul>
<li><p>负责提供读，不能接受写的请求</p></li>
<li><p>会写Master同步数据</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点</p>
<ul class="simple">
<li><p>每台节点上存储的内容是一致的</p></li>
<li><p>只有Master能够接受写的请求</p></li>
<li><p>如果Master故障，Slave不能变成Master</p></li>
</ul>
</li>
<li><p>问题</p>
<ul class="simple">
<li><p>Master存在单点故障，导致集群不可写入</p></li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li><p>修改node2和node3的配置文件</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#修改265行，指定master地址</span>
<span class="n">slaveof</span> <span class="n">node1</span> <span class="mi">6379</span>
</pre></div>
</div>
</li>
<li><p>启动所有机器的redis-server</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">export</span><span class="o">/</span><span class="n">servers</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="mf">3.2.8</span>
<span class="n">src</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">server</span> <span class="n">redis</span><span class="o">.</span><span class="n">conf</span>
<span class="n">ps</span> <span class="o">-</span><span class="n">ef</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">redis</span>
</pre></div>
</div>
</li>
<li><p>连接第一台机器客户端</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">src</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">cli</span> <span class="o">-</span><span class="n">h</span> <span class="n">node1</span>
</pre></div>
</div>
</li>
<li><p>写入一条数据</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">s1</span> <span class="n">bigdata</span>
</pre></div>
</div>
</li>
<li><p>观察其他节点的数据，在从节点尝试写入数据</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="sentinel">
<h3><span class="section-number">10.7.3. </span>哨兵模式Sentinel<a class="headerlink" href="#sentinel" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>架构</p>
<ul class="simple">
<li><p>主从架构</p>
<ul>
<li><p>主：Master</p></li>
<li><p>从：Slave</p></li>
<li><p>哨兵进程：</p>
<ul>
<li><p>负责监听Master以及其他节点，如果发现Master宕机，就会从Slave中重新选举一个新的Master</p></li>
<li><p>监听所有的节点，并且哨兵之间互相通信</p></li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>每台节点存储的数据是一样的</p></li>
</ul>
</li>
<li><p>区别：与主从复制的区别</p>
<ul>
<li><p>Slave可以选举成为Master</p></li>
</ul>
</li>
<li><p>设计</p>
<ul>
<li><p>Step1：哨兵进程会监听Master。如果有一个哨兵发现Master故障，会通知其他的哨兵</p>
<ul>
<li><p>主观性Master故障</p></li>
</ul>
</li>
<li><p>Step2：一旦达到配置的哨兵个数认为Master故障，确认Master中的故障</p>
<ul>
<li><p>客观性Master故障</p></li>
</ul>
</li>
<li><p>Step3：从Slave中根据选举规则选举出新的Master</p></li>
</ul>
</li>
</ul>
</li>
<li><p>问题</p>
<ul class="simple">
<li><p>解决了Master单点故障，但是依旧存在Redis集群存储容量负载的问题</p></li>
<li><p>哨兵本身的机制也存在一些缺点</p>
<ul>
<li><p>不支持动态扩容</p></li>
</ul>
</li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li><p>关闭三台机器的redisserver</p></li>
<li><p>修改三台机器的sentinel.conf</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/servers/redis-3.2.8
vim sentinel.conf
<span class="c1">#在第15行下面添加以下两行，指定地址和后台运行，每台机器要改成自己的主机名</span>
<span class="nb">bind</span> node1
daemonize yes
<span class="c1">#修改第71，监控master地址。mymaster是master的逻辑名称，node1是当前master的地址，2表示有2个哨兵认为故障就要切换</span>
sentinel monitor mymaster node1 <span class="m">6379</span> <span class="m">2</span>
</pre></div>
</div>
</li>
<li><p>启动三台机器的redis server和哨兵进程</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/servers/redis-3.2.8
src/redis-server redis.conf
src/redis-sentinel sentinel.conf 
ps -ef <span class="p">|</span> grep redis
</pre></div>
</div>
</li>
<li><p>测试关闭第一台进程</p></li>
<li><p>代码中如何实现连接访问</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>方案三：构建哨兵连接池：第一个参数是master的逻辑名称，第二个参数是哨兵列表，第三个是连接池的配置
HashSet&lt;String&gt; sets = new HashSet&lt;&gt;();
sets.add(&quot;node1:26379&quot;);
sets.add(&quot;node2:26379&quot;);
sets.add(&quot;node3:26379&quot;);
JedisSentinelPool mymaster = new JedisSentinelPool(&quot;mymaster&quot;, sets, jedisPoolConfig);
从连接池中获取连接
jedis = mymaster.getResource();
</pre></div>
</div>
<ul class="simple">
<li><p>解决了Master单点故障，但是依旧存在redis集群存储容量负载的问题</p></li>
<li><p>哨兵本身的机制也存在一些缺点</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id10">
<h3><span class="section-number">10.7.4. </span>集群模式<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>架构</p>
<ul class="simple">
<li><p>设计：将一个Redis的普通集群当做Redis集群模式的一个部分，利用多个Redis集群来存储不同的数据</p></li>
<li><p>去中心化思想</p></li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li><p>演示：一台机器启动三个Redis：作为三个Master，只要端口不一致即可</p></li>
<li><p>第一台机器解压重新安装</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">export</span><span class="o">/</span><span class="n">software</span><span class="o">/</span>
<span class="n">tar</span> <span class="o">-</span><span class="n">zxf</span> <span class="n">redis</span><span class="o">-</span><span class="mf">3.2.8</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">export</span><span class="o">/</span>
</pre></div>
</div>
</li>
<li><p>编译</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">export</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="mf">3.2.8</span><span class="o">/</span>
<span class="n">make</span> <span class="o">&amp;&amp;</span> <span class="n">make</span> <span class="n">install</span>
</pre></div>
</div>
</li>
<li><p>创建目录</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir -p /export/redis-3.2.8/cluster 
<span class="nb">cd</span>  /export/redis-3.2.8/cluster
mkdir <span class="m">7001</span> <span class="m">7002</span> <span class="m">7003</span> 
cp /export/redis-3.2.8/redis.conf  <span class="m">7001</span>/
</pre></div>
</div>
</li>
<li><p>修改7001目录下的配置文件</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/redis-3.2.8/cluster/7001
vim redis.conf
<span class="c1">#61行：绑定redis server地址</span>
<span class="nb">bind</span> node1
<span class="c1">#84行：修改redis实例的端口</span>
port <span class="m">7001</span>
<span class="c1">#128行：开启守护进程</span>
daemonize yes
<span class="c1">#593行：开启aof</span>
appendonly yes
<span class="c1">#721行：开启集群模式</span>
cluster-enabled yes 
<span class="c1">#729行：指定redis默认配置文件</span>
cluster-config-file nodes.conf
<span class="c1">#735行：指定超时时间</span>
cluster-node-timeout <span class="m">5000</span>
</pre></div>
</div>
</li>
<li><p>将配置文件复制给7002和7003，并修改端口为7002和7003</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/redis-3.2.8/cluster/7001
cp redis.conf ../7002/
cp redis.conf ../7003/
vim ../7002/redis.conf
<span class="c1">#84行：修改redis实例的端口</span>
port <span class="m">7002</span>
vim ../7003/redis.conf
<span class="c1">#84行：修改redis实例的端口</span>
port <span class="m">7003</span>
</pre></div>
</div>
</li>
<li><p><strong>启动三个redis实例</strong></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/redis-3.2.8/cluster/7001
redis-server redis.conf
<span class="nb">cd</span> /export/redis-3.2.8/cluster/7002
redis-server redis.conf
<span class="nb">cd</span> /export/redis-3.2.8/cluster/7003
redis-server redis.conf
</pre></div>
</div>
</li>
<li><p>安装ruby环境</p>
<ul>
<li><p>安装依赖</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">yum</span> <span class="n">install</span> <span class="n">openssl</span><span class="o">-</span><span class="n">devel</span>  <span class="n">zlib</span><span class="o">-</span><span class="n">devel</span>  <span class="o">-</span><span class="n">y</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>将ruby安装包上传到/export目录中</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /export/
tar -zxvf ruby-2.5.3.tar.gz
<span class="nb">cd</span> ruby-2.5.3
./configure --prefix<span class="o">=</span>/usr/local/ruby
make <span class="o">&amp;&amp;</span> make install
<span class="nb">echo</span> <span class="s2">&quot;export PATH=</span><span class="nv">$PATH</span><span class="s2">:/usr/local/ruby/bin&quot;</span> &gt;&gt; /etc/profile
<span class="nb">source</span> /etc/profile
gem install redis
</pre></div>
</div>
</li>
<li><p>创建redis集群</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">export</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="mf">3.2.8</span><span class="o">/</span><span class="n">src</span><span class="o">/</span>
  <span class="o">./</span><span class="n">redis</span><span class="o">-</span><span class="n">trib</span><span class="o">.</span><span class="n">rb</span> <span class="n">create</span> <span class="o">--</span><span class="n">replicas</span> <span class="mi">0</span> <span class="mf">192.168.88.221</span><span class="p">:</span><span class="mi">7001</span> <span class="mf">192.168.88.221</span><span class="p">:</span><span class="mi">7002</span> <span class="mf">192.168.88.221</span><span class="p">:</span><span class="mi">7003</span>
</pre></div>
</div>
<ul>
<li><p>可能遇到的问题</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>执行./redis-cli --cluster create ip:端口
报Node 192.168.248.12:7001 is not empty.
  	 Either the node already knows other nodes (check with CLUSTER NODES)
  	 	 or contains some key in database 0.错误

解决办法：
  	1，先kill redis创建的集群节点进程
  	2，删除每个redis节点的appendonly.aof文件，dump.rdb文件，nodes.conf文件
  		并且执行./redis-cli  使用 flushdb命令，清空每个redis里面的数据。
  	3，重启每个redis节点，再执行集群操作即可
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>启动客户端测试</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd /export/redis-3.2.8/
src/redis-cli -c -h node1 -p 7001

-c：表示是一个集群模式
</pre></div>
</div>
</li>
<li><p>常用操作</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cluster</span> <span class="pre">nodes</span></code>：列举出当前集群的所有节点，以及节点的相关信息</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cluster</span> <span class="pre">info</span></code> ：查看集群的信息</p></li>
</ul>
</li>
<li><p>Jedis代码中的连接</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">JedisCluster</span> <span class="n">jedisCluster</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="c1">//构建集群模式的额连接池</span>
<span class="n">HashSet</span><span class="o">&lt;</span><span class="n">HostAndPort</span><span class="o">&gt;</span> <span class="n">sets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">HostAndPort</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">sets</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">HostAndPort</span><span class="p">(</span><span class="s">&quot;node1&quot;</span><span class="p">,</span><span class="mi">7001</span><span class="p">));</span>
<span class="n">sets</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">HostAndPort</span><span class="p">(</span><span class="s">&quot;node1&quot;</span><span class="p">,</span><span class="mi">7002</span><span class="p">));</span>
<span class="n">sets</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">HostAndPort</span><span class="p">(</span><span class="s">&quot;node1&quot;</span><span class="p">,</span><span class="mi">7003</span><span class="p">));</span>
<span class="n">jedisCluster</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JedisCluster</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">jedisPoolConfig</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<div class="section" id="id11">
<h4><span class="section-number">10.7.4.1. </span>动态添加和删除节点<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><p>参考文章,<a class="reference external" href="https://www.cnblogs.com/maybesuch/p/10309403.html">传送门</a> 或者<a class="reference external" href="https://www.cnblogs.com/kevingrace/p/7910692.html">Redis Cluster日常操作命令梳理</a></p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="id12">
<h2><span class="section-number">10.8. </span>Redis的数据分区<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="section" id="id13">
<h3><span class="section-number">10.8.1. </span><a class="reference external" href="https://blog.csdn.net/Coxhuang/article/details/104645989/">虚拟槽分区</a><a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，</p>
<p>Redis Cluster采用虚拟槽分区，比如 Redis Cluster 槽范围是 0 ~ 16383。Redis 集群包含了 16384 个哈希槽，每个 Key 经过计算后会落在一个具体的槽位上，而每个槽位落到哪个节点上,根据自己的节点配置。</p>
</div></blockquote>
<blockquote>
<div><p>假设,当前集群有 5 个节点，每个节点平均大约负责 3276 个槽。由于采用高质量的哈希算法，每个槽所映射的数据通常比较均匀，将数据平均划分到 5 个节点进行数据分区。Redis Cluster 就是采用虚拟槽分区。</p>
<p>节点1： 包含 0 到 3276 号哈希槽。</p>
<p>节点2：包含 3277 到 6553 号哈希槽。</p>
<p>节点3：包含 6554 到 9830 号哈希槽。</p>
<p>节点4：包含 9831 到 13107 号哈希槽。</p>
<p>节点5：包含 13108 到 16383 号哈希槽。</p>
<p>注意一个思想,槽位是落在节点上的,且我们可以任意配置那些槽位落在哪个节点上</p>
<p>这种结构很容易添加或者删除节点。如果增加一个节点 6，就需要从节点 1 ~ 5 获得部分槽分配到节点 6 上。如果想移除节点 1，需要将节点 1 中的槽移到节点 2 ~ 5 上，然后将没有任何槽的节点 1 从集群中移除即可。</p>
<p>由于从一个节点将 哈希槽 移动到另一个节点并不会 停止服务，所以无论 添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
</div></blockquote>
</div>
<div class="section" id="id14">
<h3><span class="section-number">10.8.2. </span>分区的规则<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>通过槽位计算，将不同的KV存储在不同的Redis的Master中</p></li>
<li><p>Redis Cluster 采用虚拟槽分区(Redis Cluster是Redis自带的集群)，所有的键根据哈希函数映射到 0~16383 整数槽内，计算公式：<code class="docutils literal notranslate"><span class="pre">slot</span> <span class="pre">=</span> <span class="pre">CRC16（key）&amp;</span> <span class="pre">16383</span></code>。每个节点负责维护一部分槽以及槽所映射的键值数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CRC16【K】</span> <span class="pre">&amp;</span>&#160; <span class="pre">16383</span>&#160; <span class="pre">=</span>&#160; <span class="pre">0</span> <span class="pre">~</span> <span class="pre">16383</span></code></p>
<ul>
<li><p>对K进行计算</p></li>
<li><p>根据不同的槽位值，写入不同的Redis的Master中</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id15">
<h2><span class="section-number">10.9. </span>可能遇到的问题<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>1、redis-cluster 启动或者Jedis客户端连接遇到<strong>CLUSTERDOWN Hash slot not served</strong>问题</p>
<ul>
<li><p>解决办法：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="si">${</span><span class="nv">REDIS_HOME</span><span class="si">}</span>/src
redis-trib.rb check node01:7001
redis-trib.rb check node01:7002
redis-trib.rb check node01:7003
</pre></div>
</div>
<blockquote>
<div><p>node01为机器实际IP地址</p>
</div></blockquote>
</li>
<li><p>上述运行之后会提示错误</p>
<ul>
<li><p>再对每一台机器修复问题</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="si">${</span><span class="nv">REDIS_HOME</span><span class="si">}</span>/src
redis-trib.rb fix node01:7001
redis-trib.rb fix node01:7002
redis-trib.rb fix node01:7003
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>或者重新创建集群</p>
<div class="highlight-SHELL notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="si">${</span><span class="nv">REDIS_HOME</span><span class="si">}</span>/src/
./redis-trib.rb create --replicas <span class="m">0</span> <span class="m">192</span>.168.88.221:7001 <span class="m">192</span>.168.88.221:7002 <span class="m">192</span>.168.88.221:7003
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>2、JedisClusterException: CLUSTERDOWN Hash slot not served</p>
<ul>
<li><p>（1）报错JedisClusterException: CLUSTERDOWN Hash slot not served</p>
<ul class="simple">
<li><p>解决：进入redis的src目录下使用命令redis-trib.rb check 127.0.0.1:7001检测，再使用redis-cli –cluster fix 192.168.88.221:7001修复，可是又报一个ruby的loadError</p></li>
</ul>
</li>
<li><p>（2）报ruby的loadError是因为缺少redis库</p>
<ul class="simple">
<li><p>解决：使用命令gem install redis安装redis库</p></li>
</ul>
</li>
<li><p>（3）搞定以上之后再去创建集群</p>
<ul>
<li><p>解决：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 进入redis的src目录下使用命令：</span>
./redis-trib.rb create --replicas <span class="m">0</span> <span class="m">192</span>.168.88.221:7001 <span class="m">192</span>.168.88.221:7002 <span class="m">192</span>.168.88.221:7003）
<span class="c1"># 敲个yes发现还是不行，slot槽被占用</span>
</pre></div>
</div>
</li>
<li><p>错误提示： slot插槽被占用了（这是搭建redis集群前，以前redis的旧数据和配置信息没有清理干净。）</p></li>
<li><p>解决方法： 使用redis-cli 登录到每个节点执行 flushall 和 cluster reset 命令就可以了。</p>
<ul class="simple">
<li><p>登陆客户端命令： redis-cli</p></li>
<li><p>清除所有缓冲区命令： flushall</p></li>
<li><p>重置redis集群命令： cluster reset 完成之后再次创建集群即可</p></li>
</ul>
</li>
<li><p>参考：</p>
<ul class="simple">
<li><p>https://blog.csdn.net/qq_39244264/article/details/80281702</p></li>
<li><p>https://blog.csdn.net/weixin_44422604/article/details/106955119</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Spark.html" class="btn btn-neutral float-right" title="11. Spark" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Kylin.html" class="btn btn-neutral float-left" title="9. Kylin" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020-2021, roohom.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>