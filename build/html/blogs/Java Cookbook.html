

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>12. JAVA Cookbook &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="13. Maven" href="Java_Maven.html" />
    <link rel="prev" title="11. IO Stream" href="IO%E6%B5%81.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0904%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html">1. 模拟面试题整理</a></li>
<li class="toctree-l2"><a class="reference internal" href="1008%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html">2. 实时存储NoSQL模拟面试</a></li>
<li class="toctree-l2"><a class="reference internal" href="Annotation.html">3. 元注解</a></li>
<li class="toctree-l2"><a class="reference internal" href="Annotation.html#id2">4. 注解解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="Bigdata%E9%98%B2%E6%87%B5%E9%80%BC%E6%8C%87%E5%8D%97.html">5. Bigdata Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html">6. 集合</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html#id9">7. 简单(常用)数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="Flink%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86.html">8. Flink基础配置与基础原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hbase.html">9. Hbase</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hive%20SQL50%E9%A2%98%E8%AE%B0%E5%BD%95.html">10. Hive SQL50题记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="IO%E6%B5%81.html">11. <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">Stream</span></code></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">12. JAVA Cookbook</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#idea">12.1. IDEA 常用快捷键</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">12.2. 常量</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">12.3. 变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">12.4. 数据类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">12.5. 类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">12.6. 运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">12.7. 分支结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">12.8. 循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">12.9. 随机数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">12.10. 数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#java">12.11. <strong>Java程序的内存划分</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">12.12. 方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">12.13. 类和对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">12.14. 面向对象的三大特征:封装 继承 多态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">12.14.1. 构造方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">12.14.2. 继承</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id15">12.15. 抽象类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">12.16. 接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static">12.17. static关键字</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">12.18. 对象创建的过程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">12.18.1. 单个对象创建的过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">12.18.2. 子类对象创建的过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">12.18.3. 多态</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id21">12.19. 包</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">12.20. 访问修饰符</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Java_Maven.html">13. Maven</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java_OOP.html">14. Java_OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">15. 使用Java在服务端和客户端之间传送文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="Kafka.html">16. Kafka</a></li>
<li class="toctree-l2"><a class="reference internal" href="Redis.html">17. Redis</a></li>
<li class="toctree-l2"><a class="reference internal" href="SimpleDataStruct.html">18. 简单(常用)数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="Socket.html">19. Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html">20. 可能有用的学习链接</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html#hive-orc">21. Hive - ORC 文件存储格式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">22. 多线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%95%B0%E4%BB%93.html">23. 大数据平台环境与数仓</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%A2%B3%E7%90%86.html">24. 常用软件梳理</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%8B%89%E9%93%BE%E8%A1%A8.html">25. SCD</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%8B%89%E9%93%BE%E8%A1%A8.html#id2">26. 拉链表</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8EHive.html">27. 数据仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8EHive.html#hive">28. Hive</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C.html">29. 数据倾斜</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">30. 生产者消费者模型问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html">31. JavaSE_Day08</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id9">32. 面向对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#api">33. 常用API</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html">34. Java OOP防脱发指南</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Blogs</a> &raquo;</li>
        
      <li><span class="section-number">12. </span>JAVA Cookbook</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/blogs/Java Cookbook.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-cookbook">
<h1><span class="section-number">12. </span>JAVA Cookbook<a class="headerlink" href="#java-cookbook" title="永久链接至标题">¶</a></h1>
<p>[TOC]</p>
<div class="section" id="idea">
<h2><span class="section-number">12.1. </span>IDEA 常用快捷键<a class="headerlink" href="#idea" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>Alt+shift+上下方向键 移动当前代码行（选中的代码块）<br />ctrl+N 当前项目中的文件过多时，方便快速查找定位文件<br />ctrl+D 复制光标所在行（选中的代码块）<br />ctrl+Y 删除光标所在行（选中的代码块）<br />Ctrl+ALT+L 针对当前的代码进行代码格式化
ALT+Enter 在IDEA中当书写程序时，遇到红色提示时可以使用该快捷键来解决该提示问题</p>
</div></blockquote>
</div>
<div class="section" id="id1">
<h2><span class="section-number">12.2. </span>常量<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>字符常量</p>
<ul>
<li><p>字符和字符串</p>
<ul>
<li><p>字符使用单引号，如 ‘A’</p></li>
<li><p>字符串使用双引号，如”ABC”</p></li>
</ul>
</li>
</ul>
</li>
<li><p>字符串常量</p></li>
<li><p>布尔常量</p>
<ul>
<li><p>True or False</p></li>
</ul>
</li>
<li><p>空常量</p>
<ul>
<li><p>null</p></li>
<li><p>不能通过输出语句直接打印</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><span class="section-number">12.3. </span>变量<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>在程序运行过程中可以改变的量<br />变量的定义格式: 数据类型 变量名=变量值 如 int a=10；</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">12.4. </span>数据类型<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>Java是一门<strong>强类型</strong>语言：在定义变量时就指定了变量的具体类型，在程序运行过程中无法对变量的类型进行修改
弱类型:Scala语言</p>
<ul class="simple">
<li><p>基本数据类型</p>
<ul>
<li><p>整数</p>
<ul>
<li><p>byte     一个字节，取值范围:-128~127</p></li>
<li><p>short   两个字节， 15次方</p></li>
<li><p>默认 int   四个字节，31次方</p></li>
<li><p>long    八个字节</p>
<ul>
<li><p>为了区分，在值末尾加上L</p></li>
</ul>
</li>
</ul>
</li>
<li><p>小数</p>
<ul>
<li><p>float 四个字节，单精度浮点数 默认六到八位</p></li>
<li><p>默认 double 八个字节，双精度浮点数</p></li>
</ul>
</li>
<li><p>字符</p>
<ul>
<li><p>char 两个字节， 英文单引号包含的单个字符</p></li>
</ul>
</li>
<li><p>布尔Boolean 一个字节</p>
<ul>
<li><p>True</p></li>
<li><p>False
<img alt="avatar" src="../_images/charTypes.png" /></p></li>
</ul>
</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li><p>类</p></li>
<li><p>接口</p></li>
<li><p>数组[]</p></li>
</ul>
</li>
<li><p>标识符
给程序中变量、类、方法、数组等起的名字
要求(命名规则):</p>
<ul>
<li><p>标识符只能由:大小字母、数字、下划线、$组成</p></li>
<li><p>必须是以：英文字母或下划线或$开头（不能是数字开头）</p></li>
<li><p>不能是Java中的关键字</p></li>
</ul>
</li>
<li><p>命名规范:</p>
<ul>
<li><p>类名、接口的命名规范:大驼峰命名法</p></li>
<li><p>变量、方法的命名规范:小驼峰命名法</p></li>
<li><p>包的命名全部都以小写字母为主，通常名称是使用域名倒着写</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2><span class="section-number">12.5. </span>类型转换<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>自动类型转换(隐式类型转换)</p>
<ul>
<li><p>原则:小类型转换为大类型
byte -&gt; short int long float double
short -&gt; int  long float double
int -&gt; long float double
float -&gt; double
char -&gt; int -&gt; long</p></li>
</ul>
</li>
<li><p>强制类型转换(显示类型转换)</p>
<ul>
<li><p>原则: 在程序中，把大类型转换为小类型，不能自动转换，需要手动强制进行转换
格式: 小类型名 变量=(小类型名) 大类型的运算结果</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id5">
<h2><span class="section-number">12.6. </span>运算符<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>在Java中任何数据类型和字符串相加，”+”的作用都变成了拼接，其结果都是拼接字符串</p>
<ul>
<li><p>例:S.o.p(“5+5”+5+5); 输出是5+5=55</p></li>
<li><p>而S.o.p(“5+5”+(5+5));结果才是5+5=10</p></li>
</ul>
</li>
<li><p>在Java中一元运算的优先级高于二元运算</p>
<ul>
<li><p>一元运算</p>
<ul>
<li><p>自增</p>
<ul>
<li><p>只能用于变量</p></li>
<li><p>b = a++ 先赋值,再参与运算</p></li>
<li><p>b = ++a 先参与运算，再赋值</p></li>
</ul>
</li>
<li><p>自减</p>
<ul>
<li><p>道理同自增</p></li>
</ul>
</li>
</ul>
</li>
<li><p>a += 1之类的计算结果等同于  a = a+1</p></li>
<li><p>但是内部机制并不是如此:
short s=1;
s += 10;
其实等价于
short s=1;
s = (short) (s+10);</p></li>
<li><p>二元运算</p>
<ul>
<li><p>加、减、乘、除、取余</p></li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑运算符
只能针对Boolean进行运算</p>
<ul>
<li><p><strong>短路与</strong>&amp;&amp;</p>
<ul>
<li><p>作用：等同于逻辑与(&amp;)</p></li>
<li><p>特殊之处:</p>
<ul>
<li><p>当&amp;&amp;之前的运算结果为false时，其后面的运算不会再执行(在与操作中已经得到了一个否，则结果必为否)。</p></li>
<li><p>执行速度更快</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>短路或</strong>||</p>
<ul>
<li><p>作用:等同于逻辑或(|)</p></li>
<li><p>特殊之处:</p>
<ul>
<li><p>当||之前的结果为false时，其后面的表达式便不会再执行</p></li>
<li><p>速度更快</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三元运算符
格式:<br />数据类型 变量名 = (关系表达式) ? 表达式1:表达式2</p></li>
</ul>
<blockquote>
<div><p>变量接收的是表达式1的运算结果或者是表达式2的运算结果
如果关系表达式为true，则执行表达式1
如果关系表达式为false，则执行表达式2</p>
</div></blockquote>
<ul class="simple">
<li><p>键盘录入
试用步骤:</p>
<ul>
<li><p>1.导入Scanner包 import java.util.Scanner;</p></li>
<li><p>2.创建Scanner对象,Scanner sc = new Scanner(System.in);</p></li>
<li><p>3.获取键盘录入的数据:
如:String str = sc.next();
如:int num = sc.nextInt();</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id6">
<h2><span class="section-number">12.7. </span>分支结构<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>switch语句</p>
<ul>
<li><p>当判断的条件不是进行区间比较时，仅只是进行两个数据之间相等的比较时</p></li>
<li><p>switch之后的括号里可以接收变量、常量和表达式需要确保其类型必须是byte、short、int、char、String或枚举</p></li>
<li><p>default可以书写在任何位置，但除了末尾的位置都必须写break</p></li>
<li><p>case穿透现象</p></li>
<li><p><strong>假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2</strong></p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">witch</span><span class="p">(</span><span class="n">表达式</span><span class="p">){</span>
    <span class="k">case</span> <span class="n">值1</span><span class="p">:</span> 	
        <span class="n">语句体1</span><span class="p">;</span>	<span class="c1">//假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2;</span>
    <span class="k">case</span> <span class="n">值2</span><span class="p">:</span>
        <span class="n">语句体2</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">值3</span><span class="p">:</span>
        <span class="n">语句体3</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
          <span class="p">...</span>    <span class="c1">//根据需求, 可以写多组case.</span>
    <span class="k">default</span><span class="p">:</span>	
        <span class="n">语句体n</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>案例 SwitchPenetrate.java</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id7">
<h2><span class="section-number">12.8. </span>循环<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>三种循环</p>
<ul>
<li><p>for循环</p>
<ul>
<li><p>流程</p>
<ul class="simple">
<li><p>1.执行循环初始值</p></li>
<li><p>2.判断循环条件是否满足</p></li>
<li><p>3.执行for循环体重的代码</p></li>
<li><p>4.修改循环条件中的值</p></li>
<li><p>重复2、3、4</p></li>
<li><p>直到不满足循环条件</p></li>
</ul>
</li>
<li><p>特点:</p>
<ul class="simple">
<li><p>先判断，再执行循环体</p></li>
</ul>
</li>
<li><p>句式语法</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">循环初始值</span><span class="p">;</span><span class="n">循环条件</span><span class="p">;</span><span class="n">循环条件中值的修改</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">code</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><p>while循环</p></li>
<li><p>do…while循环</p></li>
</ul>
</li>
<li><p>循环三要素</p>
<ul class="simple">
<li><p>循环初始值</p></li>
<li><p>循环条件</p></li>
<li><p>循环条件中值的修改(修改循环条件)</p></li>
</ul>
</li>
<li><p>循环差异</p>
<ul class="simple">
<li><p>在for循环执行完之后，无法使用for循环里的初始化条件，比如循环执行过程中自动改变的变量</p></li>
<li><p>而在while循环执行完之后，他的循环条件却还可以使用</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id8">
<h2><span class="section-number">12.9. </span>随机数<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>在java中提供的一个获取[0.0~1.0)之间的随机数字的包Random</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>1.导入包（省去）
2.创建对象
3.使用获取随机数的功能
</pre></div>
</div>
<ul>
<li><p>使用</p>
<ul class="simple">
<li><p>格式
Math.random()</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">Math</span><span class="p">.</span><span class="na">random</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//生成一个1-100之间的随机整数</span>
</pre></div>
</div>
</li>
<li><p>在java中如果使用Math.random()生成随机数<br />如果是要生成[10,100]的随机数， (int)(Math.random()<em>91+10)<br />提取其中的(<strong>公式</strong>) :将Math.random()用MR代替。
如果是要求[a,b]范围，则是MR</em>((b-a)+1)+a<br />如果是[a,b)范围，则是MR*(b-a)+a</p></li>
</ul>
</div>
<div class="section" id="id9">
<h2><span class="section-number">12.10. </span>数组<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>定义的方式:<br />举例:</p>
<ul class="simple">
<li><p>动态初始化</p>
<ul>
<li><p>int array[] = new int[5]</p></li>
<li><p>int[] array = new int[5]</p></li>
</ul>
</li>
<li><p>静态初始化</p>
<ul>
<li><p>int[] array = new int[]{1,2,3,4,5}</p></li>
<li><p>int array[] = {1,2,3,4,5}</p></li>
</ul>
</li>
<li><p>数组的遍历可以使用for循环，同时java也提供了一个方法来直接打印数组 -&gt; Arrays.toString(arr)
打印的结果形式是[元素,元素,…]</p></li>
</ul>
</div>
<div class="section" id="java">
<h2><span class="section-number">12.11. </span><strong>Java程序的内存划分</strong><a class="headerlink" href="#java" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>栈</p>
<ul>
<li><p>作用:存储局部变量，程序要运行的代码，局部变量就是定义在方法中的变量，栈中存放的就是方法</p></li>
<li><p>特点:先进后出(FILO)</p></li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li><p>作用:存储使用new关键字，创建出来的内容(即:对象)</p></li>
<li><p>特点:存储在堆中的内容，是由Java中的垃圾回收器(GC),统一管理回收</p></li>
</ul>
</li>
<li><p>方法区:</p>
<ul>
<li><p>存放.class文件</p></li>
</ul>
</li>
<li><p>本地方法区</p>
<ul>
<li><p>常量存放在常量池中，而常量池就在方法区中</p></li>
</ul>
</li>
<li><p>寄存器</p></li>
</ul>
</div>
<div class="section" id="id10">
<h2><span class="section-number">12.12. </span>方法<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>什么是方法?</p>
<ul class="simple">
<li><p>在程序中把一段代码进行抽取并封装，封装为一个具有独立功能的代码块，这块代码起个名称之后就成为“方法”</p></li>
<li><p>main()就是一个方法</p></li>
<li><p>方法(method)也叫函数(function),在具体实现上是一样的</p></li>
<li><p>public static void main(String[] args),public static是修饰符,void表示没有返回值,main就是方法名,String[] args是参数</p></li>
</ul>
</li>
<li><p>方法可以传递数据</p></li>
<li><p>方法可以返回结果</p></li>
<li><p>好处:提高了代码的<strong>复用率</strong></p></li>
<li><p>方法的重载</p>
<ul>
<li><p>同样的方法，不同的参数列表(参数个数、参数类型以及参数的顺序)</p></li>
<li><p>参数的传递有基本数据类型和引用数据类型</p></li>
<li><p>当传递的参数是基本数据类型，形参的改变对实参没有任何影响</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用change方法前：&quot;</span> <span class="o">+</span> <span class="n">number</span><span class="p">);</span>
          <span class="n">change</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>	 <span class="c1">//实参.</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用change方法后：&quot;</span> <span class="o">+</span> <span class="n">number</span><span class="p">);</span>
      <span class="p">}</span>     
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">change</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">//形参.</span>
          <span class="n">number</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
      <span class="p">}</span>    
</pre></div>
</div>
<p><font color="red">上面代码在调用change和调用之后number的数值都是100</font></p>
</li>
<li><p>方法中传递的参数类型是引用数据类型时，传递的是地址值(内存中开辟的空间的地址值)，当在方法中对传递的引用类型的参数
进行相关操作时，会直接影响实参</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用change方法前：&quot;</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
          <span class="n">change</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用change方法后：&quot;</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">change</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
      <span class="p">}</span>
</pre></div>
</div>
<p>调用之前打印的是20，调用之后打印的是200</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<div><p>不建议在一个.java文件中书写多个类
一个.java中只允许出现一个public class
.java文件的名称必须和public class类名保持一致</p>
</div></blockquote>
</div>
<div class="section" id="id11">
<h2><span class="section-number">12.13. </span>类和对象<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>成员变量和局部变量</p>
<ul class="simple">
<li><p>在方法中定义的变量，称为局部变量</p>
<ul>
<li><p>局部变量会随着方法的入栈而存在，随着方法的出栈而销毁(存活时间:方法在栈中执行时)</p></li>
</ul>
</li>
<li><p>在类中定义的变量，称为成员变量</p>
<ul>
<li><p>随着对象的创建，而存在堆空间，随着对象对的销毁(GC的回收)而消失</p></li>
</ul>
</li>
<li><p>二者区别</p>
<ul>
<li><p>定义位置不同</p>
<ul>
<li><p>成员变量: 定义在类中, 方法外</p></li>
<li><p>局部变量: 定义在方法中, 或者方法声明上</p></li>
</ul>
</li>
<li><p>在内存中的存储位置不同</p>
<ul>
<li><p>成员变量: 存储在堆内存</p></li>
<li><p>局部变量: 存储在栈内存</p></li>
</ul>
</li>
<li><p>生命周期不同</p>
<ul>
<li><p>成员变量: 随着对象的创建而存在, 随着对象的消失而消失</p></li>
<li><p>局部变量: 随着方法的调用而存在, 随着方法的调用完毕而消失</p></li>
</ul>
</li>
<li><p>初始化值不同</p>
<ul>
<li><p>成员变量: 有默认值</p></li>
<li><p>局部变量: 没有默认值, 必须先定义, 再赋值, 然后才能使用</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>就近原则</strong></p>
<ul>
<li><p>当在方法中和方法所属的类中，有相同名称的变量时，在方法中使用变量时，<strong>优先使用局部变量</strong></p></li>
</ul>
</li>
</ul>
</li>
<li><p>在java语言中，是使用类进行编写java程序</p></li>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">类名</span><span class="p">{</span>
    <span class="c1">//书写java代码</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>在类中可以书写的内容有哪些？</p>
<ul class="simple">
<li><p>变量</p></li>
<li><p>方法</p></li>
</ul>
</li>
<li><p>在java语言中，类除了是用来定义所书写的程序外，类的另一个作用：自定义类型</p></li>
<li><p>当书写完自定义类后，需要对类进行初始化（数据类型  变量=初始化）</p></li>
<li><p>怎么对类进行初始化（初始化的动作，底层：开辟堆内存空间）</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span>类名  对象名 =  new  类名();

类名 ：  数据类型
对象名  ：  变量名
new  ：  告知JVM要开辟堆空间
类名()  ：  告知JVM要开辟空间的大小 （ 类中所书写的所有内容[变量]，进行换算，然后开辟空间 ）
           自动调用构造方法
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id12">
<h2><span class="section-number">12.14. </span>面向对象的三大特征:封装 继承 多态<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>####封装<br />什么是封装?
在面向对象中，对于事物描述是使用类进行的(把事物的属性和行为封装到类中)</p>
<p>好处:</p>
<ul>
<li><p>使用类封装，提高代码的复用性</p></li>
<li><p>安全性:隐藏了代码的内容 (private)</p></li>
<li><p>private关键字</p>
<ul class="simple">
<li><p>用来修饰类中的成员变量和成员方法</p></li>
<li><p>被private修饰的内容只能在本类中使用</p></li>
<li><p>在程序中如果使用private修饰了成员变量后，需要针对该成员变量提供public方法
虽然把成员变量饰为private，但还是需要对外提供可以访问私有成员变量的接口:public方法</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="p">{</span>
      <span class="c1">//属性, 全部用private修饰.</span>
      <span class="c1">//姓名</span>
      <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
      <span class="c1">//年龄</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

      <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">name</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="n">String</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">age</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">age</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">//行为, 也就是成员方法.</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">study</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;键盘敲烂, 月薪过万!&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;学习饿了就要吃饭!.&quot;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//测试类</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentTest</span> <span class="p">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//1. 创建学生对象.</span>
          <span class="n">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>
          <span class="c1">//2. 设置成员变量值.</span>
          <span class="n">s</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;张三&quot;</span><span class="p">);</span>
          <span class="n">s</span><span class="p">.</span><span class="na">setAge</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>
          <span class="c1">//3. 打印成员变量值.</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;...&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="na">getAge</span><span class="p">());</span>
          <span class="c1">//4. 调用成员方法.</span>
          <span class="n">s</span><span class="p">.</span><span class="na">study</span><span class="p">();</span>
          <span class="n">s</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>在开发中，通常会把类中所有的成员变量，全部修饰为private，然后提供public 数据类型 getXxx() 、
public void setXxx(数据类型 变量)方法</p>
<ul>
<li><p>快捷键 Alt+Insert 点击generate下的Getter and Setter快速生成</p></li>
</ul>
</li>
</ul>
</li>
<li><p>this关键字
是java中的关键字，表示当前类(本类对象)，其实就是<strong>用来区分局部变量和成员变量的</strong>
(前提是存在局部变量和成员变量重名)</p></li>
<li><p>super关键字</p>
<ul class="simple">
<li><p>使用方式上和this很像，super是对父类对象的引用</p></li>
<li><p>super.成员变量名 -&gt; 一定是书写在子类中</p></li>
</ul>
</li>
<li><p>static</p>
<ul class="simple">
<li><p>静态方法中不能使用this关键字</p></li>
<li><p>静态方法中只能调用静态方法</p></li>
</ul>
</li>
</ul>
<div class="section" id="id13">
<h3><span class="section-number">12.14.1. </span>构造方法<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>1.用来创建对象
2.用来给类中的成员变量进行赋值</p>
<ul class="simple">
<li><p>特征</p>
<ul>
<li><p>因为没有返回值，所以不需要return</p></li>
<li><p>构造方法名和类名完全一致</p></li>
<li><p>构造方法没有返回值，连void都不需要写</p></li>
<li><p>构造方法通常是在使用new关键字时，由JVM自动加载到栈中执行</p></li>
</ul>
</li>
<li><p>当一个类中没有书写任何构造方法时，在对类进行编译时，会自动向生成的.class文件中添加一个无参的构造方法(默认构造方法)</p></li>
<li><p>当在一个类中，有上写构造方法时，在对类进行编译时，不会再自动向生成的.class添加一个
无参的构造方法(默认的),<strong>为了确保会自动编译默认的构造方法(果需要)，必须手动将默认的构造方法进行重载</strong></p></li>
<li><p>了解构造方法中的隐式三步 <a class="reference external" href="https://blog.csdn.net/kingzone_2008/article/details/45015301">去了解</a></p>
<ul>
<li><p>1、调用父类的构造函数(super())</p>
<ul>
<li><p>三种情况:
1）构造方法体的第一行是this语句，则不会执行隐式三步，
2）构造方法体的第一行是super语句，则调用相应的父类的构造方法，
3）构造方法体的第一行既不是this语句也不是super语句，则隐式调用super()，即其父类的默认构造方法，这也是为什么一个父类通常要提供默认构造方法的原因；</p></li>
</ul>
</li>
<li><p>2、给非静态成员变量赋予显示值</p></li>
<li><p>3、执行构造代码块</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id14">
<h3><span class="section-number">12.14.2. </span>继承<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>1.什么是继承?
在一个累的基础上，另一个类继承该类，继承类可以继承前面类中的属性和行为<br />2.使用extends关键字来实现继承</p>
<p>3.书写格式:<br />- 至少需要两个类
- 需要使用extends关键字
- 继承后，继承的类可以使用被继承类中的非私有的成员变量和成员方法</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//人类，父类</span>
<span class="kd">class</span> <span class="nc">person</span><span class="p">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="c1">//学生类，子类</span>
<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
<span class="c1">//String name;</span>
<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">....</span>
<span class="p">}</span>

<span class="c1">//Person类有name成员变量，Student类中也有name成员变量，可以省略Student类中</span>
<span class="n">的name成员变量</span>
<span class="c1">//子类继承父类就可以拥有父类的一些成员变量，成员方法的访问权限(private不能访问)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>好处</p>
<ul>
<li><p>代码复用</p></li>
<li><p>代码的可维护性</p></li>
<li><p>让类和类之间建立了关系(为多态的前提)</p></li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>只能单一继承(子类只能继承于一个父类)</p></li>
<li><p>支持多层继承(A继承于B,B继承与C)</p></li>
</ul>
</li>
<li><p>构造方法的特点</p>
<ul>
<li><p>子类的每一个构造方法，默认都会先调用父类中默认的构造方法</p></li>
<li><p>当子类中没有默认的构造方法时，子类构造方法在执行时，如没有
书写super(参数)代码，则报错</p></li>
<li><p>当子类构造方法中，需要调用父类的有参构造方法时，必须在子类的构造方法中书写super(参数)，并且
<strong>必须书写在第一行</strong></p></li>
</ul>
</li>
<li><p>在继承中成员方法的特点</p>
<ul>
<li><p>1.在父子类同时具有一模一样的成员方法时，在使用子类对象.成员方法，优先调用子类的成员方法，此即是<strong>就近原则</strong></p></li>
<li><p>2.如果子类没有，就去父类中找，父类也没有就报错</p></li>
</ul>
</li>
<li><p>方法的重写(override)</p>
<ul>
<li><p>为什么要重写</p>
<ul>
<li><p>父类的该方法功能不全或者不好用，不能满足实际需求，故重写</p></li>
</ul>
</li>
<li><p>在子类中</p></li>
<li><p>子类中的方法必须和父类中的方法<strong>一模一样</strong>(名称、参数、返回值)</p></li>
<li><p>父类的private方法不能重写</p></li>
<li><p>static静态方法不能被重写，静态方法只能被继承，如果子类中定义了同名同形式的静态方法，它对父类方法只能起到
隐藏的作用，调用的时候用谁的引用，就调用谁的版本</p></li>
<li><p>父类中的方法使用public修饰时，子类中要对其重写，必须也用public</p></li>
<li><p>子类的中方法重写权限不能更低</p></li>
<li><p>白话:保证一模一样就啥事没有</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id15">
<h2><span class="section-number">12.15. </span>抽象类<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>抽象方法:当方法体中不清楚应该怎么样写具体的功能时，就可以不写具体的功能(省略方法体代码)</p>
<ul>
<li><p>当方法省略体内具体的功能时，就描述不清楚</p>
<ul>
<li><p>针对描述不清楚的内容，在java中统一使用:抽象</p></li>
</ul>
</li>
<li><p>仅声明方法，没有具体的方法体功能代码，这个方法称为:抽象方法</p>
<ul>
<li><p>抽象方法:public <strong>abstract</strong> void method(){…}</p></li>
</ul>
</li>
</ul>
</li>
<li><p>抽象类:当对事物描述不清楚时，就用抽象类</p>
<ul>
<li><p>抽象类通常是父类</p></li>
<li><p>抽象方法只能书写在抽象类中</p></li>
<li><p>抽象类不能实例化(无法实例化)</p></li>
<li><p>抽象类通常必须有一个子类</p>
<ul>
<li><p>利用多态，实现抽象类的实例化: 抽象类 父引用= new 子类;</p></li>
</ul>
</li>
</ul>
</li>
<li><p>抽象类的意义:在于“被继承”,抽象类被其子类“抽象”出了公共的部分，通常也定义了子类所必须具体实现的抽象方法。</p>
<ul>
<li><p>若一个类继承自抽象类必须重写抽象方法，否则自己也应该变成抽象类</p></li>
<li><p>因此，抽象类对子类具有强制性和规范性，这叫做模板设计模式</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id16">
<h2><span class="section-number">12.16. </span>接口<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>定义类的关键字关键字class ，定义接口的关键字是interface
继承类的关键字是extends，而实现接口的关键字是implements
当多个类型之间具有相同的行为能力的时候，java中就可以通过接口来进行类型之间的联系，通过接口可以解决单继承所带来的的一些无法共享的问题</p></li>
<li><p>语法格式</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">修饰符</span> <span class="kd">interface</span> <span class="nc">接口名称</span> <span class="o">[</span><span class="kd">extends</span> <span class="n">父接口1</span><span class="p">,</span><span class="n">父接口</span><span class="p">...</span><span class="o">]</span><span class="p">{</span>
  <span class="n">零个到多个常量的定义</span>
  <span class="n">零个到多个抽象方法的定义</span>
  <span class="n">零个到多个默认方法的定义</span>
  <span class="n">零个到多个静态方法的定义</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>注意:</p>
<blockquote>
<div><p>1.接口可以实现多继承，也就是说一个接口可同时继承多个父接口<br />2.实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类<br />3.一个类可以继承自一个父类，可以同时实现多个接口<br />4.成员变量要用 public static final修饰，也就是常量<br />5.接口中所有成员方法必须有public abstract共同修饰，也就是抽象方法</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="static">
<h2><span class="section-number">12.17. </span>static关键字<a class="headerlink" href="#static" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>通常情况下成员变量都隶属于对象层级，每个对象都拥有独立的内存空间来记录自己独有的成员变量，当所有的
对象的成员变量的值都完全一样时，若每个对象单独记录则会造成内存空间的浪费，此时应该将该成员变量由对象层级提升至
类层级，在内存空间中只保留一份且被所有的对象所共享，为了实现该效果，故使用static关键字来修饰，表示静态的含义。
static关键字可以修饰成员变量和成员方法表示隶属于类层级，推荐使用”类名.”的方式访问</p>
</div></blockquote>
<ul class="simple">
<li><p>使用方式
1.对于非静态的成员方法来说，既可以访问非静态的成员同时也可以访问静态的成员；(成员:成员变量+成员方法)
2.对于<strong>静态的成员</strong>方法来说，<strong>只能访问静态的成员</strong>，不能访问非静态的成员；(如果非要调用非静态方法，必须使用”对象.非静态方法”的方式访问，对于非静态变量也是如此)
(执行静态方法的时候<strong>可能还没有创建对象</strong>，非静态成员隶属于对象层级)
3.只有被所有对象共享的内容才能被static修饰，不能随便加</p></li>
<li><p>静态成员</p>
<ul>
<li><p>存放在JVM的方法区内</p></li>
<li><p>使用“类名.”访问</p></li>
<li><p>随着类的加载而存在，早于对象的创建</p></li>
</ul>
</li>
<li><p>非静态成员</p>
<ul>
<li><p>存放在JVM的堆内存中</p></li>
<li><p>通过“对象.”访问</p></li>
<li><p>随着对象的创建而存在，晚于对象的创建</p></li>
</ul>
</li>
<li><p>注意事项:</p>
<ul>
<li><p>静态方法中是无法使用this和super的</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id17">
<h2><span class="section-number">12.18. </span>对象创建的过程<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<div class="section" id="id18">
<h3><span class="section-number">12.18.1. </span>单个对象创建的过程<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>1.将xxx.class文件中的相关类信息读取到内存空间的方法区，这个过程叫做类的加载
2.当程序开始运行时找main()方法去执行方法体重的语句，使用new来创建对象
3.若没有指定初始值，采用默认的初始化，否则采用指定的数值来初始化
4.可以通过构造块来进行更改成员变量的数值
5.执行构造方法体中的语句，可以进行再次的修改成员变量的数值
6.此时对象创建完毕，继续执行后续的语句</p>
<p>TestSuperObject类中的静态语句块
TestSuperObject类中的构造块
TestSuperObject()的方法体</p>
</div>
<div class="section" id="id19">
<h3><span class="section-number">12.18.2. </span>子类对象创建的过程<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>1.先加载父类再去加载子类，先执行父类的静态语句块，再执行子类的静态语句块；
2.执行父类的构造块，再执行父类的构造方法体，此时父类部分构造完毕
3.执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕</p>
<p>TestSuperObject类中的静态语句块
TestSubObject类中的静态语句块
TestSuperObject类中的构造块
TestSuperObject()的方法体
TestSubObject类中的构造块
TestSubObject()的方法体</p>
<p>总结: <strong>静态块&gt;main()&gt;构造块&gt;构造方法</strong></p>
</div>
<div class="section" id="id20">
<h3><span class="section-number">12.18.3. </span>多态<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>三个条件</p>
<ul class="simple">
<li><p>1.要有继承</p></li>
<li><p>2.要有重写</p></li>
<li><p>3.父类引用指向子类对象</p></li>
</ul>
</li>
<li><p>引用类型之间的转换</p>
<ul class="simple">
<li><p>1.引用类型转换必须发生在父子类之间，分为自动类型转换(向上转型)和强制类型转换(向下转型)</p></li>
<li><p>2.向上转型(子类类型向父类转换)<br />如:Person p = new Student();</p></li>
</ul>
<blockquote>
<div><p>注意: 父类中的静态方法无法被子类重写，所以需要向上转型之后才能调用父类原有的静态方法</p>
</div></blockquote>
<ul class="simple">
<li><p>3.向下转型(父类类型向子类类型转换)
子类引用父类实例，必须进行强制类型转换，可以调用子类特有的方法，必须满足转型的条件才能。
使用instanceof运算符进行判断<br />父类的静态方法只能被子类继承而无法被子类重写</p></li>
<li><p>4.当没有父子类关系时发生强制类型转换编译报错，当拥有父子类关系时编译通过</p></li>
<li><p>为了避免上述错误的发生，通常只要进行强制类型转换就需要进行判断，格式:
if(引用变量名 instanceof 数据类型){}</p></li>
</ul>
</li>
<li><p>多态的意义</p>
<ul class="simple">
<li><p>多态的意义在于:可以屏蔽不同子类的差异性编写通用的代码，从而产生不同的效果</p></li>
</ul>
</li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//父类
abstract class Person{
    private String name;
    private int age;
    
    ....
    
    //通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
    //抽象方法： 只定义没有方法体
    public abstract void eat();
}

class Student extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校区食堂吃饭...&quot;);
    }
} 
class Teacher extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校外吃饭...&quot;);
    }
}

 class Test{
     public static void main(String[] args){
         //创建学生对象
         Student stu = new Student();
       
         method1( stu  , &quot;zs&quot; , 20  ,   .....)
         
         //创建老师对象
         Teacher tea = new Teacher();
          
         method2(  tea ,&quot;ls&quot; ,33 , ...... )
         
     }  
     
     
     
     //在书写程序时：当发现有重复的代码，建议都进行抽取封装：方法、类  （复用性）
     
      public static void method1( Student stu, String name , int age , ... ){
         stu.setName( name  );//因为Student继承了Person，可以使用父类中的非私有成员
         stu.setAge(  age  );
         ....
         stu.eat();  
      }
     
      public static void metho2 ( Teacher  tea , String name , int age , ...  ){
         tea.setName(  name   );
         tea.setAge(  age  );
         ....
         tea.eat(); 
      }
     
     //添加就业班
     
     //观察以上两个方法中的代码：除了对象名不同，其它都一样   (99%都是重复代码)
     针对代码，再次精进：
     
      public void method(  ?   , String name , int age , ...){
     
         ?.setName(  name   );
         ?.setAge(  age  );
         
         ....
         ?.eat();  
      }  
     
     ? 有两个类型：  Student 、 	Teacher
     Student类型和Teacher类型有什么相同？
     继承的父类是同一个    
     
     java语言提供了一种方案：多态
     多态的使用:
     1、要有继承关系
     2、子类要重写父类中的方法
     3、 父类的引用指向子类对象
         父类  父引用  =  new  子类();
     
     
     Person p1 = new Student();
     p1.setName(...)
     p1.eat()//调用的是对象中的eat方法
         
     Person p2 = new Teacher();
     p2.setName(....)
     p2.eat();
     
     
    
     
     
      public static void method(  Person p  ,  String name , int age , ...  ){
          
         p.setName(  name   );
         p.setAge(  age  );
         
         ....
         p.eat();  
      }
     
     
     
     Student stu = new Student();
     Person p = stu ; //多态
     
     method( stu ,&quot;ls&quot; , 20 ,....);
     
     
     Teacher tea = new Teacher();
       method( tea   );
     
         
 }
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
<span class="kd">class</span> <span class="nc">Teacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



     
     
<span class="c1">//需求升学：老师需要划分为基础班老师、就业班老师</span>
<span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
     
<span class="c1">//基础班老师    </span>
<span class="kd">class</span> <span class="nc">BasicTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;吃外卖...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>     
<span class="c1">//就业班老师    </span>
<span class="kd">class</span> <span class="nc">WorkTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>      
     

 <span class="kd">class</span> <span class="nc">Test</span><span class="p">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
         <span class="c1">//创建学生对象</span>
         <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>
         
      
         <span class="c1">//创建基础老师对象</span>
         <span class="n">BasicTeacher</span> <span class="n">tea</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BasicTeacher</span><span class="p">();</span>
         
         <span class="c1">//创建就业班老师对象</span>
         <span class="n">WorkTeacher</span> <span class="n">tea2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WorkTeacher</span><span class="p">();</span>
        
      
         <span class="n">method</span><span class="p">(</span>  <span class="n">stu</span> <span class="p">,</span> <span class="s">&quot;zs&quot;</span> <span class="p">,</span> <span class="mi">20</span>  <span class="p">)</span>
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea</span> <span class="p">,</span> <span class="s">&quot;ls&quot;</span> <span class="p">,</span> <span class="mi">33</span>  <span class="p">)</span>  
             
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea2</span>  <span class="p">,</span> <span class="s">&quot;ja&quot;</span>  <span class="mi">30</span>  <span class="p">)</span>    
         
     <span class="p">}</span>  
     
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(</span>  <span class="n">Person</span>  <span class="n">p</span> <span class="p">,</span>  <span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">){</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setAge</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
         <span class="p">...</span>
         
         <span class="n">p</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>    
      <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>在使用多态时，存在 一个问题：父引用无法使用子类中特有的成员
解决方案： 使用向下转型 （强制类型转换）</p>
<p>格式：子类  子类对象 = (子类) 父引用</p>
<p>当在进行强制类型转换时，如果父引用指向的对象类型 和 要转换的类型不匹配，就会发生：错误</p>
<p>父引用指向的对象类型 ：  Person p = new Student();  //类型：Student
要转换的类型：  Teacher
错误代码：  Teacher tea  = (Teacher ) p;//类型转换错误</p>
<p>通常在进行向下转型时，会先进行判断：</p>
<p>if( p  instanceo  Teacher){</p>
<p>Teacher tea  = (Teacher ) p;</p>
<p>}</p>
<p>父引用  instanceof  子类类型    ：  判断父引用指向的对象类型 是否为 子类类型</p>
</div></blockquote>
<p>​</p>
</div>
</div>
<div class="section" id="id21">
<h2><span class="section-number">12.19. </span>包<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>注意事项:</p>
<ul>
<li><p>package必须书写在程序的第一行</p></li>
<li><p>一个.java文件中只允许写一个package</p></li>
</ul>
</li>
<li><p>命名规则</p>
<ul>
<li><p>全部小写字符</p></li>
<li><p>包名通常是域名倒着写(企业标准)</p></li>
<li><p>通常创建报名有多个包，包之间用.连接</p></li>
</ul>
</li>
<li><p>导包</p>
<ul>
<li><p>package com.xxxx 自己的包 //本类归属的包</p></li>
<li><p>import java.util.Scanner //导包，别人写好的包</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id22">
<h2><span class="section-number">12.20. </span>访问修饰符<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<p>1.public<br />2.private<br />3.默认<br />4.protected</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
	<span class="n">Protected</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//受保护的，子类专用</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>概览
访问控制            访问权限          本类            本包中的其他类         子类          其他包中的其他类</p></li>
</ul>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">public</span>          <span class="n">公开的</span>            <span class="mi">1</span>                   <span class="mi">1</span>               <span class="mi">1</span>               <span class="mi">1</span>
   <span class="n">protected</span>       <span class="n">保护的</span>            <span class="mi">1</span>                   <span class="mi">1</span>               <span class="mi">1</span>
   <span class="n">默认方式</span>          <span class="n">默认的</span>           <span class="mi">1</span>                  <span class="mi">1</span>                            
   <span class="n">private</span>         <span class="n">私有的</span>            <span class="mi">1</span>
</pre></div>
</div>
<p>​<br />​<br />​</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Java_Maven.html" class="btn btn-neutral float-right" title="13. Maven" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="IO%E6%B5%81.html" class="btn btn-neutral float-left" title="11. IO Stream" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, roohom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>