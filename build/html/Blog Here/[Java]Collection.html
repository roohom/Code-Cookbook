<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>22. [Java]集合 &mdash; Code-Cookbook 0.2 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="24. [Java]IO Stream" href="%5BJava%5DIO%E6%B5%81.html" />
    <link rel="prev" title="20. [Java]元注解" href="%5BJava%5DAnnotation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Code-Cookbook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Boxed%20Error.html">1. [Springboot x spark]java.util.concurrent.ExecutionException: Boxed Error</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BApollo%5DApollo%20Config%20Center.html">2. [Apollo]Apollo Config Center</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BConfluent%5DConfluent.html">3. [Confluent]Confluent快速上手</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DCommdLine%2BSpringboot%2Bflink%E6%97%A0%E6%B3%95%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8.html">4. [Flink]CommdLine+Springboot+flink无法指定配置文件启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DFlink-connector-http.html">5. [Flink]Flink-connector-http</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DFlinkSource.html">6. [Flink]Flink Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DProcessFunction%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%8A%9B%E5%87%BAInvalidProgramException.html">7. [Flink]ProcessFunction无法使用，抛出InvalidProgramException</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%97%E5%AD%90%E5%B0%86stream%E8%81%9A%E5%90%88%E8%BE%93%E5%87%BA.html">8. [Flink]使用状态算子将stream聚合输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E5%A6%82%E4%BD%95%E6%9B%B4%E9%80%9A%E7%94%A8%E5%9C%B0%E5%B0%86Kafka%28%E6%88%96%E5%85%B6%E4%BB%96%29%E6%95%B0%E6%8D%AE%E8%90%BD%E5%9C%B0Hive%EF%BC%9F.html">9. [Flink]如何更通用地将Kafka(或其他)数据落地Hive？</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%B6%88%E8%B4%B9Kafka%E6%95%B0%E6%8D%AE.html">10. [Flink]自定义序列化消费Kafka数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BGit%5DGit.html">11. [Git]Git问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BGit%5D%E8%AF%AF%E5%9C%A8Master%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B9%B6commit%E6%97%A0%E6%B3%95push.html">12. [Git]误在Master分支开发并commit无法push</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHadoop%5DHadoop%20distcp.html">13. [Hadoop]Hadoop distcp</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHadoop%5D%E4%B8%80%E4%BA%9BHadoop%E9%97%AE%E9%A2%98.html">14. [Hadoop]一些Hadoop问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5DHive%E5%88%86%E5%8C%BA%E8%A1%A8%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E5%88%86%E5%8C%BA.html">15. [Hive]Hive分区表批量删除分区</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5.html">16. [Hive]在指定位置添加字段</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E5%A4%96%E9%83%A8%E8%A1%A8%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%86%85%E9%83%A8%E8%A1%A8.html">17. [Hive]外部表修改为内部表</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81Kerberos%E8%AE%A4%E8%AF%81%E7%9A%84Hive.html">18. [Hive]本地连接需要Kerberos认证的Hive</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJAVA%5DJava%20Cookbook.html">19. [JAVA]JAVA Cookbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DAnnotation.html">20. [Java]元注解</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DAnnotation.html#id1">21. 注解解析</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">22. [Java]集合</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">22.1. 内部类</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">22.1.1. 匿名内部类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id3">22.2. 集合</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">22.2.1. 泛型:约束的类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">22.2.2. 集合的遍历</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list">22.2.3. List集合</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#for">22.3. 增强For循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">22.4. 集合的遍历</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">22.5. 数据结构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">23. 简单(常用)数据结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">23.1. 栈</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">23.2. 队列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">23.3. 可变数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">23.4. 链表</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set">23.5. Set集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">23.6. 可变参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#map">23.7. Map集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">23.8. 小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DIO%E6%B5%81.html">24. [Java]<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">Stream</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DJava8%20Stream.html">25. [Java]Java8 Stream API</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DOOP.html">26. [Java]Java_OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DSocket.html">27. [Java]Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">28. [Java]使用Java在服务端和客户端之间传送文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8.html">29. [Java]三种策略模式应用于服务的启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">30. [Java]多线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">31. [Java]生产者消费者模型问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%A9%E9%A1%B9%E7%9B%AE%E9%A1%BA%E5%88%A9%E8%AF%BB%E5%8F%96resources%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6.html">32. [Java]让项目顺利读取resources目录下的文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">33. [Java]设计模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#continuing">34. Continuing…</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html">35. [Java]设计模式六大原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html">36. [Java]面向对象知识点梳理</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html">37. [Java]OOP防脱发指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKerberos%5DMessage%20stream%20modified%20%2841%29%E9%94%99%E8%AF%AF.html">38. [Kerberos]Message stream modified (41)错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKudu%5D%E5%85%B3%E4%BA%8EKudu%20Upsert%E5%88%97%E7%9A%84%E9%97%AE%E9%A2%98.html">39. [Kudu]关于Kudu Upsert列的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKudu%5D%E5%85%B3%E4%BA%8EKudu%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%BF%AE%E6%94%B9.html">40. [Kudu]关于Kudu列的顺序的修改</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BMongoDB%5DMongoDB%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2.html">41. [MongoDB]MongoDB基本查询</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BPySpark%5DPySpark.html">42. [Pyspark]PySpark</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BPySpark%5DPySparkOnYarn.html">43. [PySpark]PySpark On Yarn</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5DSQLIn%26NotIn.html">44. [SQL]<code class="docutils literal notranslate"><span class="pre">IN</span></code> OR <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">IN</span></code> , IS A PROBLEM</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%60create_time%60%E5%92%8C%60update_time%60.html">45. [SQL]业务数据库中的<code class="docutils literal notranslate"><span class="pre">create_time</span></code>和<code class="docutils literal notranslate"><span class="pre">update_time</span></code>分析时的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E4%B8%BA%E4%BB%80%E4%B9%88LEFT%20JOIN%E5%90%8E%E6%80%BB%E6%95%B0%E5%8D%B4%E4%B8%8E%E5%8F%B3%E8%A1%A8%E7%9A%84%E6%80%BB%E6%95%B0%E4%B8%80%E6%A0%B7%E4%BA%86%EF%BC%9F.html">46. [SQL]为什么LEFT JOIN后总数却与右表的总数一样了？</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E6%B1%82%E7%94%A8%E6%88%B7%E4%BB%BB%E6%84%8F%E5%A4%A9%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%28%E6%AF%8F%E5%A4%A9%E4%B8%BA%E7%AC%AC%E5%A4%9A%E5%B0%91%E5%A4%A9%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%29.html">47. [SQL]求用户任意天连续登录(每天为第多少天连续登录)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E8%AE%A1%E7%AE%97%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84%E5%B9%B4-%E5%91%A8%28%E4%B8%BA%E6%9F%90%E5%B9%B4%E7%9A%84%E7%AC%AC%E5%A4%9A%E5%B0%91%E5%91%A8%29.html">48. [SQL]计算指定日期的<strong>年-周</strong>(为某年的第多少周)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BScala%5DClosure%26Currying.html">49. [Scala]函数中闭包(Closure)和柯里化(Currying)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5DEOF.html">50. [Shell]EOF</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5Dshell%E8%84%9A%E6%9C%AC%E6%97%A5%E6%9C%9F%E9%80%92%E5%A2%9E%28%E8%B5%B7%E6%AD%A2%E6%97%A5%E6%9C%9F%E5%86%85%E9%80%92%E5%A2%9E%29.html">51. [Shell]Shell脚本日期递增(起止日期内递增)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5D%E6%89%93%E5%8D%B0%E6%9C%AC%E6%9C%BAIP.html">52. [Shell]打印本机IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSparkStreaming%5D%E6%B6%88%E8%B4%B9kafka%E5%86%99%E5%85%A5Hive%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html">53. [SparkStreaming]消费kafka写入Hive失败的问题Lease timeout of 0 seconds expired</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSparkSQL%20%E5%88%97%E8%BD%AC%E8%A1%8C%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95.html">54. [Spark]SparkSQL 列转行的一种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSparkSQLJDBC%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E8%AF%BB%E5%8F%96.html">55. [Spark]SparkSQL JDBC并发连接读取</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSpark%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1RSA%20premaster%20secret%20error.html">56. [Spark]Spark提交任务RSA premaster secret error</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSpringboot%E6%95%B4%E5%90%88Spark%2C%20%E6%9C%AC%E5%9C%B0%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.html">57. [Spark]Springboot整合Spark, 本地、集群部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5D%E4%BD%BF%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AARow.html">58. [Spark]如何使用Java创建一个Row</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5D%E5%B0%86Spark%20DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E5%8F%96%E5%87%BA.html">59. [Spark]将Spark DataFrame中的数值取出</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpringboot%5DokHttp%E9%94%99%E8%AF%AFException%20in%20thread%20OkHttp%20Dispatcher%20java.lang.IllegalStateException%20closed.html">60. [Springboot]okHttp错误:<em>Exception</em> in thread “OkHttp Dispatcher” <em>java.lang.IllegalStateException</em>: closed</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BVim%5D%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4.html">61. [Vim]Vim查找和替换命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5Bdebezium%5D%E5%9C%A8%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1%E6%97%B6%E4%BC%A0%E5%85%A5SQL%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90Snapshot.html">62. [debezium]在启动任务时传入SQL语句生成Snapshot</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5Bdebezium%5D%E7%83%AD%E4%BF%AE%E6%94%B9DebeziumMySQLConnector%E9%85%8D%E7%BD%AE.html">63. [debezium]热修改Debezium MySQL Connector配置</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Blogs</a> &raquo;</li>
      <li><span class="section-number">22. </span>[Java]集合</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Blog Here/[Java]Collection.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="java">
<h1><span class="section-number">22. </span>[Java]集合<a class="headerlink" href="#java" title="永久链接至标题"></a></h1>
<section id="id1">
<h2><span class="section-number">22.1. </span>内部类<a class="headerlink" href="#id1" title="永久链接至标题"></a></h2>
<p>概念:在一个类中定义另一个类</p>
<ul>
<li><p>两种内部类</p>
<ul>
<li><p>成员内部类
书写的位置和成员变量、成员方法在同一个位置(方法外)</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
      <span class="c1">//成员内部类</span>
      <span class="kd">public</span> <span class="kd">class</span> <span class="nc">InnerClass</span><span class="p">{</span>

      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>局部内部类</p>
<ul class="simple">
<li><p>局部内部类</p>
<ul>
<li><p>书写在成员方法内</p></li>
<li><p>不能使用访问修饰符</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<section id="id2">
<h3><span class="section-number">22.1.1. </span>匿名内部类<a class="headerlink" href="#id2" title="永久链接至标题"></a></h3>
<p>匿名内部类:匿名对象+子类</p>
<ul>
<li><p>匿名对象</p>
<ul class="simple">
<li><p>Student stu = new Student();创建一个Student对象</p>
<ul>
<li><p>访问方法:stu.method()</p></li>
</ul>
</li>
<li><p>匿名对象格式:</p>
<ul>
<li><p>书写格式:new Student()</p></li>
<li><p>访问内部成员方法 new Student().method()</p></li>
</ul>
</li>
<li><p>作用:通常用于作实参传递</p></li>
</ul>
</li>
<li><p>子类</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="n">exdents</span> <span class="n">Person</span><span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>匿名内部类+子类
一个继承了类或者接口的子类对象</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Student</span>
<span class="p">{</span>
    <span class="c1">//重写方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
    <span class="p">}</span>
<span class="p">}</span> 
</pre></div>
</div>
<ul class="simple">
<li><p>使用</p>
<ul>
<li><p>1.当抽象类或接口中没有过多方法使用也比较少，可以考虑使用匿名内部类的方式</p></li>
<li><p>2.匿名内部类可以作为方法的实参进行传递</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="id3">
<h2><span class="section-number">22.2. </span>集合<a class="headerlink" href="#id3" title="永久链接至标题"></a></h2>
<ul>
<li><p>概念:</p>
<ul class="simple">
<li><p>集合是用来存储多个同类型的数据的容器，它的长度是可以变化的</p></li>
</ul>
</li>
<li><p>集合的体系结构</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">Collection接口</span><span class="p">:</span>  
    <span class="o">|---</span> <span class="n">List接口</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">ArrayListL类</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">LinkedList类</span><span class="p">:</span>  
    <span class="o">|---</span> <span class="n">Set接口</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">Hash类</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">TreeSet类</span><span class="p">:</span>        
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>归属于Java.util</p>
</div></blockquote>
<ul class="simple">
<li><p>Collection是一个接口，属于java集合体系中顶层的父接口，该接口下有两大体系:List、Set</p>
<ul>
<li><p>List特点:有序、可重复</p></li>
<li><p>Set特点:无序、唯一</p></li>
</ul>
</li>
<li><p>使用方式</p>
<ul>
<li><p>属于接口，无法实例化，需要借助子类,通过多态的方式创建子类对象</p></li>
<li><p>collection coll = new ArrayList();</p></li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><p>添加:public boolean add(Object obj);</p></li>
<li><p>删除 public boolean remove(Object obj);</p></li>
<li><p>修改 在遍历的过程中针对某个元素进行修改</p></li>
<li><p>查询 需要借助迭代器进行遍历查询</p></li>
<li><p>获取元素个数 public int size();</p></li>
<li><p>是否包含某个元素 public boolean contains(Object obj);</p></li>
<li><p>清空所有元素 public void clear();</p></li>
<li><p>判断是否为空 public boolean isEmpty();</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>集合内装的元素都经过了类型提升为Object(比如整形经过了自动装箱)</p>
</div></blockquote>
<section id="id4">
<h3><span class="section-number">22.2.1. </span>泛型:约束的类型<a class="headerlink" href="#id4" title="永久链接至标题"></a></h3>
<p>常用于创建集合时使用，用来约束集合中可以存储的元素的类型</p>
</section>
<section id="id5">
<h3><span class="section-number">22.2.2. </span>集合的遍历<a class="headerlink" href="#id5" title="永久链接至标题"></a></h3>
<ul>
<li><p>集合没有类似数组一样的索引，无法利用索引进行遍历，需要借助迭代器</p>
<ul class="simple">
<li><p>Iterator it = Collection.iterator();</p></li>
<li><p>常用方法:</p>
<ul>
<li><p>public boolean hasNext()	//判断迭代器中是否还有下一个元素.</p></li>
<li><p>public E next()			//获取迭代器中的下一个元素.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>集合遍历的大致过程</p>
<ul class="simple">
<li><p>1.创建集合对象.</p></li>
<li><p>2.创建元素对象.</p></li>
<li><p>3.把元素添加到集合中.</p></li>
<li><p>4.遍历集合</p>
<ul>
<li><p>1.根据集合对象获取其对应的迭代器对象.
通过Collection#iterator()方法实现.</p></li>
<li><p>2.判断迭代器中是否有下一个元素.
通过Iterator#hasNext()方法实现.</p></li>
<li><p>3.如果有, 就获取该元素.
通过Iterator#next()方法实现.</p></li>
</ul>
</li>
<li><p>案例:</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="c1">//案例: 演示Collection集合存储自定义对象, 并遍历</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="p">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//1. 创建集合对象.</span>
          <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
          <span class="c1">//2. 创建元素对象.</span>
          <span class="n">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;刘亦菲&quot;</span><span class="p">,</span> <span class="mi">33</span><span class="p">);</span>
          <span class="n">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;赵丽颖&quot;</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
          <span class="n">Student</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;高圆圆&quot;</span><span class="p">,</span> <span class="mi">35</span><span class="p">);</span>
          <span class="c1">//Student s4 = new Student(&quot;丹丹&quot;, 18);</span>
          <span class="c1">//3. 把元素对象添加到集合对象中.</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span>
          <span class="c1">//coll.add(s4);</span>
          <span class="c1">//4. 遍历集合.</span>
          <span class="c1">//4.1 根据集合对象获取其对应的迭代器对象. Collection#iterator();</span>
          <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">coll</span><span class="p">.</span><span class="na">iterator</span><span class="p">();</span>
          <span class="c1">//4.2 判断迭代器中是否有下一个元素. Iterator#hasNext();</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="na">hasNext</span><span class="p">())</span> <span class="p">{</span>
              <span class="c1">//4.3 有就获取. Iterator#next();</span>
              <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="na">next</span><span class="p">();</span>
              <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">stu</span><span class="p">);</span>

              <span class="c1">//不能写成如下的形式, 因为next()方法调用一次, 就会获取一个值.</span>
              <span class="c1">//下边这个代码就属于: 判断一次, 获取两个值.</span>
              <span class="c1">//System.out.println(it.next().getName() + &quot;...&quot; + it.next().getAge());</span>
          <span class="p">}</span>
      <span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="list">
<h3><span class="section-number">22.2.3. </span>List集合<a class="headerlink" href="#list" title="永久链接至标题"></a></h3>
<ul class="simple">
<li><p>特点:</p>
<ul>
<li><p>1.存取元素有序。存储元素的顺序和取出元素的顺序一致</p></li>
<li><p>2.list集合允许存储重复元素</p></li>
<li><p>3.list集合中有索引，可以利用索引精确访问集合中的每一个元素</p></li>
</ul>
</li>
<li><p>创建:</p>
<ul>
<li><p>没有构造方法</p></li>
<li><p>List是一个接口，无法实例化，需要借助子类</p></li>
<li><p>List list = new ArrayList();</p></li>
<li><p>List继承于Collection,父接口的相关功能，list集合也可以使用</p></li>
</ul>
</li>
<li><p>常用方法(特有方法):</p>
<ul>
<li><p>添加 void add(int index, Object obj)</p></li>
<li><p>修改 Object set(int index, Object obj) //指定索引位置上的元素修改为Obj，并返回修改之前的元素</p></li>
<li><p>删除</p>
<ul>
<li><p>boolean remove(Object obj) 删除指定对象</p></li>
<li><p>Object remove(int index) 删除指定位置元素并返回旧元素</p></li>
</ul>
</li>
<li><p>查询</p>
<ul>
<li><p>Object get(int index) 查询到元素并返回</p></li>
<li><p>int indexOf(Object obj)</p></li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li><p>iterator迭代器(见ListDemo4.java)</p></li>
<li><p>ListIterator迭代器(专有)</p></li>
<li><p>四种方式:</p>
<ul>
<li><p>1.Iterator迭代器</p>
<ul>
<li><p>不适合遍历的同时增删</p></li>
</ul>
</li>
<li><p>2.ListIterator迭代器</p></li>
<li><p>3.for循环</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>迭代器</p>
<ul>
<li><p>普通迭代器的弊端</p>
<ul>
<li><p>在迭代遍历时，如果向list集合中<strong>添加</strong>新元素或<strong>删除</strong>元素，迭代器会引发异常:ConcurrentModificationException</p></li>
<li><p>解决办法:</p>
<ul>
<li><p>使用专用迭代器:ListIterator (ListIterator listIt = list.ListIterator())</p></li>
</ul>
</li>
</ul>
</li>
<li><p>增强for循环的底层是迭代器</p></li>
</ul>
</li>
</ul>
<section id="aarraylist">
<h4><span class="section-number">22.2.3.1. </span>AarrayList类<a class="headerlink" href="#aarraylist" title="永久链接至标题"></a></h4>
<ul class="simple">
<li><p>底层使用可变<strong>数组</strong></p></li>
<li><p>特点</p>
<ul>
<li><p>存取有序，有索引</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>查询和修改效率比较高</p></li>
<li><p>添加和删除元素效率比较低</p></li>
</ul>
</li>
</ul>
</section>
<section id="linkedlist">
<h4><span class="section-number">22.2.3.2. </span>LinkedList类<a class="headerlink" href="#linkedlist" title="永久链接至标题"></a></h4>
<ul class="simple">
<li><p>底层使用<strong>链表</strong></p></li>
<li><p>在创建LinkedList时所指定的索引，可以指定位置，但是在查询的时候用不上</p></li>
<li><p>特点</p>
<ul>
<li><p>存取有序</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>可以存储null</p></li>
<li><p>有角标，但是底层是链表结构用不上</p></li>
<li><p>添加和删除元素效率高</p></li>
<li><p>查询较慢，修改元素值较慢</p>
<ul>
<li><p>链表特性:有头有尾</p></li>
</ul>
</li>
</ul>
</li>
<li><p>特有方法(针对链表的头和尾设计的):</p>
<ul>
<li><p>添加:</p>
<ul>
<li><p>addFirst(Object obj)</p></li>
<li><p>addLast(Object obj)</p></li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><p>removeFirst()</p></li>
<li><p>removeLast()</p></li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li><p>getFirst()</p></li>
<li><p>getLast()</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</section>
</section>
<section id="for">
<h2><span class="section-number">22.3. </span>增强For循环<a class="headerlink" href="#for" title="永久链接至标题"></a></h2>
<p>增强for循环是用来遍历的，针数组和集合的遍历</p>
<ul class="simple">
<li><p>弊端</p>
<ul>
<li><p>只能用来遍历</p></li>
<li><p>增强for的底层其实是通过迭代器(Iterator)实现的</p></li>
</ul>
</li>
<li><p>格式:</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="n">元素类型</span> <span class="n">变量名</span> <span class="p">:</span> <span class="n">array</span><span class="p">){</span>
    <span class="c1">//直接使用变量名就可以获取到array中的每一个元素</span>
<span class="p">}</span>

<span class="c1">//集合</span>
<span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="n">元素类型</span> <span class="n">元素名</span><span class="p">:</span> <span class="n">list</span><span class="p">){</span>
    <span class="c1">//打印</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>在循环过程中不能向集合中添加元素或者删除元素</p>
</div></blockquote>
</section>
<section id="id6">
<h2><span class="section-number">22.4. </span>集合的遍历<a class="headerlink" href="#id6" title="永久链接至标题"></a></h2>
<ul class="simple">
<li><p>1.普通迭代器</p>
<ul>
<li><p>iterator it = 集合对象.iterator()</p></li>
</ul>
</li>
<li><p>2.专用迭代器</p>
<ul>
<li><p>只适用于List</p></li>
<li><p>ListIterator li = 集合对象.listIterator()</p></li>
</ul>
</li>
<li><p>3.普通for循环</p></li>
<li><p>4.增强for循环</p></li>
</ul>
<p><strong>如果要对集合元素进行删除修改应该使用for循环和专用迭代器</strong></p>
</section>
<section id="id7">
<h2><span class="section-number">22.5. </span>数据结构<a class="headerlink" href="#id7" title="永久链接至标题"></a></h2>
</section>
</section>
<section id="id8">
<h1><span class="section-number">23. </span>简单(常用)数据结构<a class="headerlink" href="#id8" title="永久链接至标题"></a></h1>
<ul class="simple">
<li><p>栈</p></li>
<li><p>队列</p></li>
<li><p>数组(可变数组)</p></li>
<li><p>链表</p></li>
</ul>
<section id="id9">
<h2><span class="section-number">23.1. </span>栈<a class="headerlink" href="#id9" title="永久链接至标题"></a></h2>
<ul class="simple">
<li><p>特点:FILO,先进后出</p></li>
</ul>
</section>
<section id="id10">
<h2><span class="section-number">23.2. </span>队列<a class="headerlink" href="#id10" title="永久链接至标题"></a></h2>
<ul class="simple">
<li><p>特点:FIFO,先进先出</p></li>
</ul>
</section>
<section id="id11">
<h2><span class="section-number">23.3. </span>可变数组<a class="headerlink" href="#id11" title="永久链接至标题"></a></h2>
<p>创建新数组，将原数组中元素选择性拷贝到新数组中</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>有索引</p></li>
<li><p>查询效率高</p></li>
</ul>
</li>
</ul>
</section>
<section id="id12">
<h2><span class="section-number">23.4. </span>链表<a class="headerlink" href="#id12" title="永久链接至标题"></a></h2>
<p>内存中的存储节点，每个节点通过地址值链接在一起</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>查找元素时，从链表的头部开始遍历查找</p></li>
<li><p>无索引</p></li>
<li><p>查询效率低</p></li>
<li><p>添加删除元素的效率高</p></li>
</ul>
</li>
<li><p>单链表</p></li>
<li><p>双链表</p></li>
</ul>
</section>
<section id="set">
<h2><span class="section-number">23.5. </span>Set集合<a class="headerlink" href="#set" title="永久链接至标题"></a></h2>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>存取无序，唯一</p></li>
<li><p>不能存储重复元素</p></li>
<li><p>是一个接口，无法实例化，需要借助子类</p></li>
<li><p>无索引，不能通过for循环遍历</p></li>
</ul>
</li>
<li><p>子类:HashSet和TreeSet</p>
<ul>
<li><p>HashSet底层使用哈希表结构</p>
<ul>
<li><p>哈希表结构在存储元素时的过程</p>
<ul>
<li><p>1.拿出存储的元素，结合哈希算法，计算出元素的存储位置</p>
<ul>
<li><p>借助了HashCode()方法</p></li>
</ul>
</li>
<li><p>2.把存储的元素存放到计算出来的位置上</p>
<ul>
<li><p>判断在该位置上是否已经存在元素</p>
<ul>
<li><p>没有:直接在该位置存储</p></li>
<li><p>有:比较两个元素是否相同(要存储的元素、已存在的元素)</p>
<ul>
<li><p>相同:意味着元素一样，不用存储</p></li>
<li><p>不同:拉链法(拿计算出来的位置，再次结合哈希算法重新计算存储的位置)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TreeSet底层使用树结构</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>在使用HashSet集合存储自定义对象时，如果希望所存储的自定义对象属性的值不能重复时，需要对HashCode()和equals()方法进行重写</p>
</div></blockquote>
<ul class="simple">
<li><p>遍历</p>
<ul>
<li><p>迭代器</p></li>
<li><p>增强for</p></li>
<li><p>toArray()</p></li>
</ul>
</li>
</ul>
</section>
<section id="id13">
<h2><span class="section-number">23.6. </span>可变参数<a class="headerlink" href="#id13" title="永久链接至标题"></a></h2>
<p>定义不同的参数的方法，通过重载来实现，但是当参数的个数越来越多时，重载就不好使了，就需要使用可变参数</p>
<ul class="simple">
<li><p>格式:</p>
<ul>
<li><p>修饰符 返回值类型 方法名(数值类型… 变量名)</p></li>
</ul>
</li>
<li><p>要求</p>
<ul>
<li><p>可变参数必须书写在方法参数声明的最后一个参数位置上</p></li>
<li><p>在方法参数声明时，只能存在一个可变参数(不考虑参数类型)</p></li>
<li><p>当方法中需要传递其他参数时，需要将这些参数书写在可变参数之前</p></li>
</ul>
</li>
</ul>
</section>
<section id="map">
<h2><span class="section-number">23.7. </span>Map集合<a class="headerlink" href="#map" title="永久链接至标题"></a></h2>
<p>是一个接口，不能实例化，需要借助子类</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>底层使用了两个单列集合</p></li>
<li><p>存储两个元素:一次存储一对元素(键值对)</p></li>
<li><p>存储的Key元素不能重复(底层使用使用Set集合来存储键)</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|--</span><span class="n">HashMap类</span>
<span class="o">|--</span><span class="n">TreeMap类</span>
</pre></div>
</div>
<ul class="simple">
<li><p>常用方法:</p>
<ul>
<li><p>添加:</p>
<ul>
<li><p>public V put(Object key,Object value)</p>
<ul>
<li><p>一次性向集合中添加键值对这一对元素，并返回value</p></li>
<li><p>底层实现:现在Map集合中通过key来判断是否存在的key元素</p>
<ul>
<li><p>有:就直接针对当前的key，来修改value(新的覆盖旧的)，返回旧的value</p></li>
<li><p>没有，直接添加</p></li>
</ul>
</li>
<li><p>如果Map是空集合，第一次使用put方法，返回的是null，因此可以通过判断返回的是不是null来判断是不是第一次天剑</p></li>
</ul>
</li>
</ul>
</li>
<li><p>修改:</p>
<ul>
<li><p>public V put(Object key,Object value)</p></li>
</ul>
</li>
<li><p>删除:</p>
<ul>
<li><p>public V remove(Object key) //根据指定的键删除集合中相应的一对元素，返回被删除的value</p></li>
</ul>
</li>
<li><p>查询:public V get(Object key) //根据指定的key元素，获取集合中匹配的value元素</p></li>
<li><p>判断:</p>
<ul>
<li><p>boolean containsKey(Object key)</p></li>
<li><p>boolean containsValue(Object value)</p></li>
<li><p>boolean isEmpty() 判断是否为空</p></li>
</ul>
</li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li><p>Map集合本身无法遍历，Map集合中没有迭代器</p></li>
<li><p>Map集合的遍历:</p>
<ul>
<li><p>1.使用存储Key元素的Set集合，实现遍历</p>
<ul>
<li><p>1.先获取到存储所有Key元素的Set集合</p>
<ul>
<li><p>Map集合对象中的KeySet()方法</p></li>
</ul>
</li>
<li><p>2.遍历Set集合(迭代器，增强for)</p></li>
<li><p>3.遍历过程中获取每一个key元素</p></li>
<li><p>4.利用Map集合中的get(Object key),实现通过key获取value</p></li>
</ul>
</li>
<li><p>2.向Map集合中存储的一对键值对对象类型是:Map.Entry类型</p>
<ul>
<li><p>1.利用Map集合中的方法，获取集合中所有的Map.Entry</p></li>
<li><p>2.遍历所有的Map.Entry</p></li>
<li><p>3.利用Map.Entry对象中的方法，分别获取:Key,Value</p>
<ul>
<li><p>EntrySet()</p>
<ul>
<li><p>获取所有的键值对对象集合(Set集合&lt;Map.Entry&gt;)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="id14">
<h2><span class="section-number">23.8. </span>小结<a class="headerlink" href="#id14" title="永久链接至标题"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|---Collection集合(接口):单列集合的顶层父接口
    |---List集合(接口):存取有序、有索引、元素可重复
        |---ArrayList集合(类):底层使用数组，查询修改比较高快
            |--- 常用方法:add remove set get
        |---LinkList集合(类):底层使用链表，删除添加比较快
            |---常用方法:addFirst addLast removeFirst removeLast getFirst getLast
    |---Set集合(接口):存取无序，没有索引，元素唯一
        |---常用方法:全部来自于Collection
        |---HashSet集合(类):底层使用哈希表
        |---TreeSet集合(类):底层使用树(二叉树)结构
        |---LinkedHashSet(类):底层使用哈希表+链表结构。特点，有序存取
|---Map集合(接口):双列集合的顶层父接口
    |---常用方法:put remove get
        Set KeySet() 获取双列集合中用来存储所有的Key元素的单列集合
        Set&lt;Map.Entry&gt; entrySet
    |---HashMap集合(类):底层使用哈希表
    |---TreeMap集合(类):底层使用树结构

</pre></div>
</div>
<blockquote>
<div><p>当拿捏不定时，选择List集合</p>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="%5BJava%5DAnnotation.html" class="btn btn-neutral float-left" title="20. [Java]元注解" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="%5BJava%5DIO%E6%B5%81.html" class="btn btn-neutral float-right" title="24. [Java]IO Stream" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2020-2022, roohom.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>