

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>6. 集合 &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="8. Commands" href="Commands.html" />
    <link rel="prev" title="5. Scala函数中闭包(Closure)和柯里化(Currying)" href="Closure%26Currying.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0904%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html">1. 面试题整理</a></li>
<li class="toctree-l2"><a class="reference internal" href="1008%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html">2. 实时存储NoSQL面试</a></li>
<li class="toctree-l2"><a class="reference internal" href="Annotation.html">3. 元注解</a></li>
<li class="toctree-l2"><a class="reference internal" href="Annotation.html#id2">4. 注解解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closure%26Currying.html">5. Scala函数中闭包(Closure)和柯里化(Currying)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6. 集合</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">6.1. 内部类</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">6.1.1. 匿名内部类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">6.2. 集合</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">6.2.1. 泛型:约束的类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">6.2.2. 集合的遍历</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list">6.2.3. List集合</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#for">6.3. 增强For循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">6.4. 集合的遍历</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">6.5. 数据结构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id9">7. 简单(常用)数据结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">7.1. 栈</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">7.2. 队列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">7.3. 可变数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">7.4. 链表</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set">7.5. Set集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">7.6. 可变参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#map">7.7. Map集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">7.8. 小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Commands.html">8. Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="EOF.html">9. EOF</a></li>
<li class="toctree-l2"><a class="reference internal" href="Git.html">10. Git问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hadoop%20distcp.html">11. Hadoop distcp</a></li>
<li class="toctree-l2"><a class="reference internal" href="Hive%20SQL50%E9%A2%98%E8%AE%B0%E5%BD%95.html">12. Hive SQL50题记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="IO%E6%B5%81.html">13. <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">Stream</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%20Cookbook.html">14. JAVA Cookbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java8%20Stream%28%29.html">15. Java8 Stream API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java_Maven.html">16. Maven</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java_OOP.html">17. Java_OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">18. 使用Java在服务端和客户端之间传送文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="PySpark.html">19. PySpark</a></li>
<li class="toctree-l2"><a class="reference internal" href="PySparkOnYarn.html">20. PySpark On Yarn</a></li>
<li class="toctree-l2"><a class="reference internal" href="SimpleDataStruct.html">21. 简单(常用)数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="Socket.html">22. Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="Spark%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1RSA%20premaster%20secret%20error.html">23. Spark提交任务RSA premaster secret error</a></li>
<li class="toctree-l2"><a class="reference internal" href="Springboot%E6%95%B4%E5%90%88Spark%2C%20%E6%9C%AC%E5%9C%B0%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.html">24. Springboot整合Spark, 本地、集群部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="Vim%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4.html">25. Vim查找和替换命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="shell%E8%84%9A%E6%9C%AC%E6%97%A5%E6%9C%9F%E9%80%92%E5%A2%9E%28%E8%B5%B7%E6%AD%A2%E6%97%A5%E6%9C%9F%E5%86%85%E9%80%92%E5%A2%9E%29.html">26. Shell脚本日期递增(起止日期内递增)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%85%B3%E4%BA%8EKudu%20Upsert%E5%88%97%E7%9A%84%E9%97%AE%E9%A2%98.html">27. 关于Kudu Upsert列的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%85%B3%E4%BA%8EKudu%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%BF%AE%E6%94%B9.html">28. 关于Kudu列的顺序的修改</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html">29. 可能有用的学习链接</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html#hive-orc">30. Hive - ORC 文件存储格式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">31. 多线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%B0%86Spark%20DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E5%8F%96%E5%87%BA.html">32. 将Spark DataFrame中的数值取出</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%89%93%E5%8D%B0%E6%9C%AC%E6%9C%BAIP.html">33. 打印本机IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81Kerberos%E8%AE%A4%E8%AF%81%E7%9A%84Hive.html">34. 本地连接需要Kerberos认证的Hive</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">35. 生产者消费者模型问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">36. JAVA设计模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#continuing">37. Continuing…</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html">38. 设计模式六大原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html">39. 面向对象知识点梳理</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html">40. Java OOP防脱发指南</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Blogs</a> &raquo;</li>
        
      <li><span class="section-number">6. </span>集合</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Blog Here/Collection.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1><span class="section-number">6. </span>集合<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2><span class="section-number">6.1. </span>内部类<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>概念:在一个类中定义另一个类</p>
<ul>
<li><p>两种内部类</p>
<ul>
<li><p>成员内部类
书写的位置和成员变量、成员方法在同一个位置(方法外)</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
      <span class="c1">//成员内部类</span>
      <span class="kd">public</span> <span class="kd">class</span> <span class="nc">InnerClass</span><span class="p">{</span>

      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>局部内部类</p>
<ul class="simple">
<li><p>局部内部类</p>
<ul>
<li><p>书写在成员方法内</p></li>
<li><p>不能使用访问修饰符</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="section" id="id3">
<h3><span class="section-number">6.1.1. </span>匿名内部类<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>匿名内部类:匿名对象+子类</p>
<ul>
<li><p>匿名对象</p>
<ul class="simple">
<li><p>Student stu = new Student();创建一个Student对象</p>
<ul>
<li><p>访问方法:stu.method()</p></li>
</ul>
</li>
<li><p>匿名对象格式:</p>
<ul>
<li><p>书写格式:new Student()</p></li>
<li><p>访问内部成员方法 new Student().method()</p></li>
</ul>
</li>
<li><p>作用:通常用于作实参传递</p></li>
</ul>
</li>
<li><p>子类</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="n">exdents</span> <span class="n">Person</span><span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>匿名内部类+子类
一个继承了类或者接口的子类对象</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Student</span>
<span class="p">{</span>
    <span class="c1">//重写方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
    <span class="p">}</span>
<span class="p">}</span> 
</pre></div>
</div>
<ul class="simple">
<li><p>使用</p>
<ul>
<li><p>1.当抽象类或接口中没有过多方法使用也比较少，可以考虑使用匿名内部类的方式</p></li>
<li><p>2.匿名内部类可以作为方法的实参进行传递</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id4">
<h2><span class="section-number">6.2. </span>集合<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>概念:</p>
<ul class="simple">
<li><p>集合是用来存储多个同类型的数据的容器，它的长度是可以变化的</p></li>
</ul>
</li>
<li><p>集合的体系结构</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">Collection接口</span><span class="p">:</span>  
    <span class="o">|---</span> <span class="n">List接口</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">ArrayListL类</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">LinkedList类</span><span class="p">:</span>  
    <span class="o">|---</span> <span class="n">Set接口</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">Hash类</span><span class="p">:</span>  
        <span class="o">|---</span><span class="n">TreeSet类</span><span class="p">:</span>        
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>归属于Java.util</p>
</div></blockquote>
<ul class="simple">
<li><p>Collection是一个接口，属于java集合体系中顶层的父接口，该接口下有两大体系:List、Set</p>
<ul>
<li><p>List特点:有序、可重复</p></li>
<li><p>Set特点:无序、唯一</p></li>
</ul>
</li>
<li><p>使用方式</p>
<ul>
<li><p>属于接口，无法实例化，需要借助子类,通过多态的方式创建子类对象</p></li>
<li><p>collection coll = new ArrayList();</p></li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><p>添加:public boolean add(Object obj);</p></li>
<li><p>删除 public boolean remove(Object obj);</p></li>
<li><p>修改 在遍历的过程中针对某个元素进行修改</p></li>
<li><p>查询 需要借助迭代器进行遍历查询</p></li>
<li><p>获取元素个数 public int size();</p></li>
<li><p>是否包含某个元素 public boolean contains(Object obj);</p></li>
<li><p>清空所有元素 public void clear();</p></li>
<li><p>判断是否为空 public boolean isEmpty();</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>集合内装的元素都经过了类型提升为Object(比如整形经过了自动装箱)</p>
</div></blockquote>
<div class="section" id="id5">
<h3><span class="section-number">6.2.1. </span>泛型:约束的类型<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>常用于创建集合时使用，用来约束集合中可以存储的元素的类型</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">6.2.2. </span>集合的遍历<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>集合没有类似数组一样的索引，无法利用索引进行遍历，需要借助迭代器</p>
<ul class="simple">
<li><p>Iterator it = Collection.iterator();</p></li>
<li><p>常用方法:</p>
<ul>
<li><p>public boolean hasNext()	//判断迭代器中是否还有下一个元素.</p></li>
<li><p>public E next()			//获取迭代器中的下一个元素.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>集合遍历的大致过程</p>
<ul class="simple">
<li><p>1.创建集合对象.</p></li>
<li><p>2.创建元素对象.</p></li>
<li><p>3.把元素添加到集合中.</p></li>
<li><p>4.遍历集合</p>
<ul>
<li><p>1.根据集合对象获取其对应的迭代器对象.
通过Collection#iterator()方法实现.</p></li>
<li><p>2.判断迭代器中是否有下一个元素.
通过Iterator#hasNext()方法实现.</p></li>
<li><p>3.如果有, 就获取该元素.
通过Iterator#next()方法实现.</p></li>
</ul>
</li>
<li><p>案例:</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="c1">//案例: 演示Collection集合存储自定义对象, 并遍历</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="p">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//1. 创建集合对象.</span>
          <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
          <span class="c1">//2. 创建元素对象.</span>
          <span class="n">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;刘亦菲&quot;</span><span class="p">,</span> <span class="mi">33</span><span class="p">);</span>
          <span class="n">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;赵丽颖&quot;</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
          <span class="n">Student</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">(</span><span class="s">&quot;高圆圆&quot;</span><span class="p">,</span> <span class="mi">35</span><span class="p">);</span>
          <span class="c1">//Student s4 = new Student(&quot;丹丹&quot;, 18);</span>
          <span class="c1">//3. 把元素对象添加到集合对象中.</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
          <span class="n">coll</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span>
          <span class="c1">//coll.add(s4);</span>
          <span class="c1">//4. 遍历集合.</span>
          <span class="c1">//4.1 根据集合对象获取其对应的迭代器对象. Collection#iterator();</span>
          <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">coll</span><span class="p">.</span><span class="na">iterator</span><span class="p">();</span>
          <span class="c1">//4.2 判断迭代器中是否有下一个元素. Iterator#hasNext();</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="na">hasNext</span><span class="p">())</span> <span class="p">{</span>
              <span class="c1">//4.3 有就获取. Iterator#next();</span>
              <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="na">next</span><span class="p">();</span>
              <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">stu</span><span class="p">);</span>

              <span class="c1">//不能写成如下的形式, 因为next()方法调用一次, 就会获取一个值.</span>
              <span class="c1">//下边这个代码就属于: 判断一次, 获取两个值.</span>
              <span class="c1">//System.out.println(it.next().getName() + &quot;...&quot; + it.next().getAge());</span>
          <span class="p">}</span>
      <span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="list">
<h3><span class="section-number">6.2.3. </span>List集合<a class="headerlink" href="#list" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>特点:</p>
<ul>
<li><p>1.存取元素有序。存储元素的顺序和取出元素的顺序一致</p></li>
<li><p>2.list集合允许存储重复元素</p></li>
<li><p>3.list集合中有索引，可以利用索引精确访问集合中的每一个元素</p></li>
</ul>
</li>
<li><p>创建:</p>
<ul>
<li><p>没有构造方法</p></li>
<li><p>List是一个接口，无法实例化，需要借助子类</p></li>
<li><p>List list = new ArrayList();</p></li>
<li><p>List继承于Collection,父接口的相关功能，list集合也可以使用</p></li>
</ul>
</li>
<li><p>常用方法(特有方法):</p>
<ul>
<li><p>添加 void add(int index, Object obj)</p></li>
<li><p>修改 Object set(int index, Object obj) //指定索引位置上的元素修改为Obj，并返回修改之前的元素</p></li>
<li><p>删除</p>
<ul>
<li><p>boolean remove(Object obj) 删除指定对象</p></li>
<li><p>Object remove(int index) 删除指定位置元素并返回旧元素</p></li>
</ul>
</li>
<li><p>查询</p>
<ul>
<li><p>Object get(int index) 查询到元素并返回</p></li>
<li><p>int indexOf(Object obj)</p></li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li><p>iterator迭代器(见ListDemo4.java)</p></li>
<li><p>ListIterator迭代器(专有)</p></li>
<li><p>四种方式:</p>
<ul>
<li><p>1.Iterator迭代器</p>
<ul>
<li><p>不适合遍历的同时增删</p></li>
</ul>
</li>
<li><p>2.ListIterator迭代器</p></li>
<li><p>3.for循环</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>迭代器</p>
<ul>
<li><p>普通迭代器的弊端</p>
<ul>
<li><p>在迭代遍历时，如果向list集合中<strong>添加</strong>新元素或<strong>删除</strong>元素，迭代器会引发异常:ConcurrentModificationException</p></li>
<li><p>解决办法:</p>
<ul>
<li><p>使用专用迭代器:ListIterator (ListIterator listIt = list.ListIterator())</p></li>
</ul>
</li>
</ul>
</li>
<li><p>增强for循环的底层是迭代器</p></li>
</ul>
</li>
</ul>
<div class="section" id="aarraylist">
<h4><span class="section-number">6.2.3.1. </span>AarrayList类<a class="headerlink" href="#aarraylist" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p>底层使用可变<strong>数组</strong></p></li>
<li><p>特点</p>
<ul>
<li><p>存取有序，有索引</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>查询和修改效率比较高</p></li>
<li><p>添加和删除元素效率比较低</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="linkedlist">
<h4><span class="section-number">6.2.3.2. </span>LinkedList类<a class="headerlink" href="#linkedlist" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p>底层使用<strong>链表</strong></p></li>
<li><p>在创建LinkedList时所指定的索引，可以指定位置，但是在查询的时候用不上</p></li>
<li><p>特点</p>
<ul>
<li><p>存取有序</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>可以存储null</p></li>
<li><p>有角标，但是底层是链表结构用不上</p></li>
<li><p>添加和删除元素效率高</p></li>
<li><p>查询较慢，修改元素值较慢</p>
<ul>
<li><p>链表特性:有头有尾</p></li>
</ul>
</li>
</ul>
</li>
<li><p>特有方法(针对链表的头和尾设计的):</p>
<ul>
<li><p>添加:</p>
<ul>
<li><p>addFirst(Object obj)</p></li>
<li><p>addLast(Object obj)</p></li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><p>removeFirst()</p></li>
<li><p>removeLast()</p></li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li><p>getFirst()</p></li>
<li><p>getLast()</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="for">
<h2><span class="section-number">6.3. </span>增强For循环<a class="headerlink" href="#for" title="永久链接至标题">¶</a></h2>
<p>增强for循环是用来遍历的，针数组和集合的遍历</p>
<ul class="simple">
<li><p>弊端</p>
<ul>
<li><p>只能用来遍历</p></li>
<li><p>增强for的底层其实是通过迭代器(Iterator)实现的</p></li>
</ul>
</li>
<li><p>格式:</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="n">元素类型</span> <span class="n">变量名</span> <span class="p">:</span> <span class="n">array</span><span class="p">){</span>
    <span class="c1">//直接使用变量名就可以获取到array中的每一个元素</span>
<span class="p">}</span>

<span class="c1">//集合</span>
<span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="n">元素类型</span> <span class="n">元素名</span><span class="p">:</span> <span class="n">list</span><span class="p">){</span>
    <span class="c1">//打印</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>在循环过程中不能向集合中添加元素或者删除元素</p>
</div></blockquote>
</div>
<div class="section" id="id7">
<h2><span class="section-number">6.4. </span>集合的遍历<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>1.普通迭代器</p>
<ul>
<li><p>iterator it = 集合对象.iterator()</p></li>
</ul>
</li>
<li><p>2.专用迭代器</p>
<ul>
<li><p>只适用于List</p></li>
<li><p>ListIterator li = 集合对象.listIterator()</p></li>
</ul>
</li>
<li><p>3.普通for循环</p></li>
<li><p>4.增强for循环</p></li>
</ul>
<p><strong>如果要对集合元素进行删除修改应该使用for循环和专用迭代器</strong></p>
</div>
<div class="section" id="id8">
<h2><span class="section-number">6.5. </span>数据结构<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
</div>
</div>
<div class="section" id="id9">
<h1><span class="section-number">7. </span>简单(常用)数据结构<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>栈</p></li>
<li><p>队列</p></li>
<li><p>数组(可变数组)</p></li>
<li><p>链表</p></li>
</ul>
<div class="section" id="id10">
<h2><span class="section-number">7.1. </span>栈<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>特点:FILO,先进后出</p></li>
</ul>
</div>
<div class="section" id="id11">
<h2><span class="section-number">7.2. </span>队列<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>特点:FIFO,先进先出</p></li>
</ul>
</div>
<div class="section" id="id12">
<h2><span class="section-number">7.3. </span>可变数组<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>创建新数组，将原数组中元素选择性拷贝到新数组中</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>有索引</p></li>
<li><p>查询效率高</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id13">
<h2><span class="section-number">7.4. </span>链表<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>内存中的存储节点，每个节点通过地址值链接在一起</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>查找元素时，从链表的头部开始遍历查找</p></li>
<li><p>无索引</p></li>
<li><p>查询效率低</p></li>
<li><p>添加删除元素的效率高</p></li>
</ul>
</li>
<li><p>单链表</p></li>
<li><p>双链表</p></li>
</ul>
</div>
<div class="section" id="set">
<h2><span class="section-number">7.5. </span>Set集合<a class="headerlink" href="#set" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>存取无序，唯一</p></li>
<li><p>不能存储重复元素</p></li>
<li><p>是一个接口，无法实例化，需要借助子类</p></li>
<li><p>无索引，不能通过for循环遍历</p></li>
</ul>
</li>
<li><p>子类:HashSet和TreeSet</p>
<ul>
<li><p>HashSet底层使用哈希表结构</p>
<ul>
<li><p>哈希表结构在存储元素时的过程</p>
<ul>
<li><p>1.拿出存储的元素，结合哈希算法，计算出元素的存储位置</p>
<ul>
<li><p>借助了HashCode()方法</p></li>
</ul>
</li>
<li><p>2.把存储的元素存放到计算出来的位置上</p>
<ul>
<li><p>判断在该位置上是否已经存在元素</p>
<ul>
<li><p>没有:直接在该位置存储</p></li>
<li><p>有:比较两个元素是否相同(要存储的元素、已存在的元素)</p>
<ul>
<li><p>相同:意味着元素一样，不用存储</p></li>
<li><p>不同:拉链法(拿计算出来的位置，再次结合哈希算法重新计算存储的位置)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TreeSet底层使用树结构</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>在使用HashSet集合存储自定义对象时，如果希望所存储的自定义对象属性的值不能重复时，需要对HashCode()和equals()方法进行重写</p>
</div></blockquote>
<ul class="simple">
<li><p>遍历</p>
<ul>
<li><p>迭代器</p></li>
<li><p>增强for</p></li>
<li><p>toArray()</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id14">
<h2><span class="section-number">7.6. </span>可变参数<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<p>定义不同的参数的方法，通过重载来实现，但是当参数的个数越来越多时，重载就不好使了，就需要使用可变参数</p>
<ul class="simple">
<li><p>格式:</p>
<ul>
<li><p>修饰符 返回值类型 方法名(数值类型… 变量名)</p></li>
</ul>
</li>
<li><p>要求</p>
<ul>
<li><p>可变参数必须书写在方法参数声明的最后一个参数位置上</p></li>
<li><p>在方法参数声明时，只能存在一个可变参数(不考虑参数类型)</p></li>
<li><p>当方法中需要传递其他参数时，需要将这些参数书写在可变参数之前</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="map">
<h2><span class="section-number">7.7. </span>Map集合<a class="headerlink" href="#map" title="永久链接至标题">¶</a></h2>
<p>是一个接口，不能实例化，需要借助子类</p>
<ul class="simple">
<li><p>特点</p>
<ul>
<li><p>底层使用了两个单列集合</p></li>
<li><p>存储两个元素:一次存储一对元素(键值对)</p></li>
<li><p>存储的Key元素不能重复(底层使用使用Set集合来存储键)</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|--</span><span class="n">HashMap类</span>
<span class="o">|--</span><span class="n">TreeMap类</span>
</pre></div>
</div>
<ul class="simple">
<li><p>常用方法:</p>
<ul>
<li><p>添加:</p>
<ul>
<li><p>public V put(Object key,Object value)</p>
<ul>
<li><p>一次性向集合中添加键值对这一对元素，并返回value</p></li>
<li><p>底层实现:现在Map集合中通过key来判断是否存在的key元素</p>
<ul>
<li><p>有:就直接针对当前的key，来修改value(新的覆盖旧的)，返回旧的value</p></li>
<li><p>没有，直接添加</p></li>
</ul>
</li>
<li><p>如果Map是空集合，第一次使用put方法，返回的是null，因此可以通过判断返回的是不是null来判断是不是第一次天剑</p></li>
</ul>
</li>
</ul>
</li>
<li><p>修改:</p>
<ul>
<li><p>public V put(Object key,Object value)</p></li>
</ul>
</li>
<li><p>删除:</p>
<ul>
<li><p>public V remove(Object key) //根据指定的键删除集合中相应的一对元素，返回被删除的value</p></li>
</ul>
</li>
<li><p>查询:public V get(Object key) //根据指定的key元素，获取集合中匹配的value元素</p></li>
<li><p>判断:</p>
<ul>
<li><p>boolean containsKey(Object key)</p></li>
<li><p>boolean containsValue(Object value)</p></li>
<li><p>boolean isEmpty() 判断是否为空</p></li>
</ul>
</li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li><p>Map集合本身无法遍历，Map集合中没有迭代器</p></li>
<li><p>Map集合的遍历:</p>
<ul>
<li><p>1.使用存储Key元素的Set集合，实现遍历</p>
<ul>
<li><p>1.先获取到存储所有Key元素的Set集合</p>
<ul>
<li><p>Map集合对象中的KeySet()方法</p></li>
</ul>
</li>
<li><p>2.遍历Set集合(迭代器，增强for)</p></li>
<li><p>3.遍历过程中获取每一个key元素</p></li>
<li><p>4.利用Map集合中的get(Object key),实现通过key获取value</p></li>
</ul>
</li>
<li><p>2.向Map集合中存储的一对键值对对象类型是:Map.Entry类型</p>
<ul>
<li><p>1.利用Map集合中的方法，获取集合中所有的Map.Entry</p></li>
<li><p>2.遍历所有的Map.Entry</p></li>
<li><p>3.利用Map.Entry对象中的方法，分别获取:Key,Value</p>
<ul>
<li><p>EntrySet()</p>
<ul>
<li><p>获取所有的键值对对象集合(Set集合&lt;Map.Entry&gt;)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id15">
<h2><span class="section-number">7.8. </span>小结<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|---Collection集合(接口):单列集合的顶层父接口
    |---List集合(接口):存取有序、有索引、元素可重复
        |---ArrayList集合(类):底层使用数组，查询修改比较高快
            |--- 常用方法:add remove set get
        |---LinkList集合(类):底层使用链表，删除添加比较快
            |---常用方法:addFirst addLast removeFirst removeLast getFirst getLast
    |---Set集合(接口):存取无序，没有索引，元素唯一
        |---常用方法:全部来自于Collection
        |---HashSet集合(类):底层使用哈希表
        |---TreeSet集合(类):底层使用树(二叉树)结构
        |---LinkedHashSet(类):底层使用哈希表+链表结构。特点，有序存取
|---Map集合(接口):双列集合的顶层父接口
    |---常用方法:put remove get
        Set KeySet() 获取双列集合中用来存储所有的Key元素的单列集合
        Set&lt;Map.Entry&gt; entrySet
    |---HashMap集合(类):底层使用哈希表
    |---TreeMap集合(类):底层使用树结构

</pre></div>
</div>
<blockquote>
<div><p>当拿捏不定时，选择List集合</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Commands.html" class="btn btn-neutral float-right" title="8. Commands" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Closure%26Currying.html" class="btn btn-neutral float-left" title="5. Scala函数中闭包(Closure)和柯里化(Currying)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020-2021, roohom.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>