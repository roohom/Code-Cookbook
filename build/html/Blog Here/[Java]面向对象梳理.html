<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>36. [Java]面向对象知识点梳理 &mdash; Code-Cookbook 0.2 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="37. [Java]OOP防脱发指南" href="%5BJava%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" />
    <link rel="prev" title="35. [Java]设计模式六大原则" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Code-Cookbook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Boxed%20Error.html">1. [Springboot x spark]java.util.concurrent.ExecutionException: Boxed Error</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BApollo%5DApollo%20Config%20Center.html">2. [Apollo]Apollo Config Center</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BConfluent%5DConfluent.html">3. [Confluent]Confluent快速上手</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DCommdLine%2BSpringboot%2Bflink%E6%97%A0%E6%B3%95%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8.html">4. [Flink]CommdLine+Springboot+flink无法指定配置文件启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DFlink-connector-http.html">5. [Flink]Flink-connector-http</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DFlinkSource.html">6. [Flink]Flink Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5DProcessFunction%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%8A%9B%E5%87%BAInvalidProgramException.html">7. [Flink]ProcessFunction无法使用，抛出InvalidProgramException</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%97%E5%AD%90%E5%B0%86stream%E8%81%9A%E5%90%88%E8%BE%93%E5%87%BA.html">8. [Flink]使用状态算子将stream聚合输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E5%A6%82%E4%BD%95%E6%9B%B4%E9%80%9A%E7%94%A8%E5%9C%B0%E5%B0%86Kafka%28%E6%88%96%E5%85%B6%E4%BB%96%29%E6%95%B0%E6%8D%AE%E8%90%BD%E5%9C%B0Hive%EF%BC%9F.html">9. [Flink]如何更通用地将Kafka(或其他)数据落地Hive？</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BFlink%5D%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%B6%88%E8%B4%B9Kafka%E6%95%B0%E6%8D%AE.html">10. [Flink]自定义序列化消费Kafka数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BGit%5DGit.html">11. [Git]Git问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BGit%5D%E8%AF%AF%E5%9C%A8Master%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B9%B6commit%E6%97%A0%E6%B3%95push.html">12. [Git]误在Master分支开发并commit无法push</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHadoop%5DHadoop%20distcp.html">13. [Hadoop]Hadoop distcp</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHadoop%5D%E4%B8%80%E4%BA%9BHadoop%E9%97%AE%E9%A2%98.html">14. [Hadoop]一些Hadoop问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5DHive%E5%88%86%E5%8C%BA%E8%A1%A8%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E5%88%86%E5%8C%BA.html">15. [Hive]Hive分区表批量删除分区</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5.html">16. [Hive]在指定位置添加字段</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E5%A4%96%E9%83%A8%E8%A1%A8%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%86%85%E9%83%A8%E8%A1%A8.html">17. [Hive]外部表修改为内部表</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BHive%5D%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81Kerberos%E8%AE%A4%E8%AF%81%E7%9A%84Hive.html">18. [Hive]本地连接需要Kerberos认证的Hive</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJAVA%5DJava%20Cookbook.html">19. [JAVA]JAVA Cookbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DAnnotation.html">20. [Java]元注解</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DAnnotation.html#id1">21. 注解解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DCollection.html">22. [Java]集合</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DCollection.html#id8">23. 简单(常用)数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DIO%E6%B5%81.html">24. [Java]<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">Stream</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DJava8%20Stream.html">25. [Java]Java8 Stream API</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DOOP.html">26. [Java]Java_OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DSocket.html">27. [Java]Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5DSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">28. [Java]使用Java在服务端和客户端之间传送文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8.html">29. [Java]三种策略模式应用于服务的启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">30. [Java]多线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">31. [Java]生产者消费者模型问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%A9%E9%A1%B9%E7%9B%AE%E9%A1%BA%E5%88%A9%E8%AF%BB%E5%8F%96resources%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6.html">32. [Java]让项目顺利读取resources目录下的文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">33. [Java]设计模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#continuing">34. Continuing…</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html">35. [Java]设计模式六大原则</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">36. [Java]面向对象知识点梳理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">36.1. 面向对象知识点梳理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">36.1.1. 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">36.1.2. 对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">36.1.3. 封装</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">36.1.4. 构造方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">36.1.5. 继承</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thissuper">36.1.6. this和super</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">36.1.7. 多态</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">36.1.8. 接口</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id9">36.2. 面向对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">36.2.1. 包</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">36.2.2. 访问修饰符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#api">36.3. 常用API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#object">36.3.1. Object类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string">36.3.2. String类</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="%5BJava%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html">37. [Java]OOP防脱发指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKerberos%5DMessage%20stream%20modified%20%2841%29%E9%94%99%E8%AF%AF.html">38. [Kerberos]Message stream modified (41)错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKudu%5D%E5%85%B3%E4%BA%8EKudu%20Upsert%E5%88%97%E7%9A%84%E9%97%AE%E9%A2%98.html">39. [Kudu]关于Kudu Upsert列的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BKudu%5D%E5%85%B3%E4%BA%8EKudu%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%BF%AE%E6%94%B9.html">40. [Kudu]关于Kudu列的顺序的修改</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BMongoDB%5DMongoDB%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2.html">41. [MongoDB]MongoDB基本查询</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BPySpark%5DPySpark.html">42. [Pyspark]PySpark</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BPySpark%5DPySparkOnYarn.html">43. [PySpark]PySpark On Yarn</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5DSQLIn%26NotIn.html">44. [SQL]<code class="docutils literal notranslate"><span class="pre">IN</span></code> OR <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">IN</span></code> , IS A PROBLEM</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%60create_time%60%E5%92%8C%60update_time%60.html">45. [SQL]业务数据库中的<code class="docutils literal notranslate"><span class="pre">create_time</span></code>和<code class="docutils literal notranslate"><span class="pre">update_time</span></code>分析时的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E4%B8%BA%E4%BB%80%E4%B9%88LEFT%20JOIN%E5%90%8E%E6%80%BB%E6%95%B0%E5%8D%B4%E4%B8%8E%E5%8F%B3%E8%A1%A8%E7%9A%84%E6%80%BB%E6%95%B0%E4%B8%80%E6%A0%B7%E4%BA%86%EF%BC%9F.html">46. [SQL]为什么LEFT JOIN后总数却与右表的总数一样了？</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E6%B1%82%E7%94%A8%E6%88%B7%E4%BB%BB%E6%84%8F%E5%A4%A9%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%28%E6%AF%8F%E5%A4%A9%E4%B8%BA%E7%AC%AC%E5%A4%9A%E5%B0%91%E5%A4%A9%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%29.html">47. [SQL]求用户任意天连续登录(每天为第多少天连续登录)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSQL%5D%E8%AE%A1%E7%AE%97%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84%E5%B9%B4-%E5%91%A8%28%E4%B8%BA%E6%9F%90%E5%B9%B4%E7%9A%84%E7%AC%AC%E5%A4%9A%E5%B0%91%E5%91%A8%29.html">48. [SQL]计算指定日期的<strong>年-周</strong>(为某年的第多少周)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BScala%5DClosure%26Currying.html">49. [Scala]函数中闭包(Closure)和柯里化(Currying)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5DEOF.html">50. [Shell]EOF</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5Dshell%E8%84%9A%E6%9C%AC%E6%97%A5%E6%9C%9F%E9%80%92%E5%A2%9E%28%E8%B5%B7%E6%AD%A2%E6%97%A5%E6%9C%9F%E5%86%85%E9%80%92%E5%A2%9E%29.html">51. [Shell]Shell脚本日期递增(起止日期内递增)</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BShell%5D%E6%89%93%E5%8D%B0%E6%9C%AC%E6%9C%BAIP.html">52. [Shell]打印本机IP</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSparkStreaming%5D%E6%B6%88%E8%B4%B9kafka%E5%86%99%E5%85%A5Hive%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html">53. [SparkStreaming]消费kafka写入Hive失败的问题Lease timeout of 0 seconds expired</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSparkSQL%20%E5%88%97%E8%BD%AC%E8%A1%8C%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95.html">54. [Spark]SparkSQL 列转行的一种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSparkSQLJDBC%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E8%AF%BB%E5%8F%96.html">55. [Spark]SparkSQL JDBC并发连接读取</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSpark%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1RSA%20premaster%20secret%20error.html">56. [Spark]Spark提交任务RSA premaster secret error</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5DSpringboot%E6%95%B4%E5%90%88Spark%2C%20%E6%9C%AC%E5%9C%B0%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.html">57. [Spark]Springboot整合Spark, 本地、集群部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5D%E4%BD%BF%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AARow.html">58. [Spark]如何使用Java创建一个Row</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpark%5D%E5%B0%86Spark%20DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E5%8F%96%E5%87%BA.html">59. [Spark]将Spark DataFrame中的数值取出</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BSpringboot%5DokHttp%E9%94%99%E8%AF%AFException%20in%20thread%20OkHttp%20Dispatcher%20java.lang.IllegalStateException%20closed.html">60. [Springboot]okHttp错误:<em>Exception</em> in thread “OkHttp Dispatcher” <em>java.lang.IllegalStateException</em>: closed</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5BVim%5D%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4.html">61. [Vim]Vim查找和替换命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5Bdebezium%5D%E5%9C%A8%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1%E6%97%B6%E4%BC%A0%E5%85%A5SQL%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90Snapshot.html">62. [debezium]在启动任务时传入SQL语句生成Snapshot</a></li>
<li class="toctree-l2"><a class="reference internal" href="%5Bdebezium%5D%E7%83%AD%E4%BF%AE%E6%94%B9DebeziumMySQLConnector%E9%85%8D%E7%BD%AE.html">63. [debezium]热修改Debezium MySQL Connector配置</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Blogs</a> &raquo;</li>
      <li><span class="section-number">36. </span>[Java]面向对象知识点梳理</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Blog Here/[Java]面向对象梳理.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="java">
<h1><span class="section-number">36. </span>[Java]面向对象知识点梳理<a class="headerlink" href="#java" title="永久链接至标题"></a></h1>
<section id="id1">
<h2><span class="section-number">36.1. </span>面向对象知识点梳理<a class="headerlink" href="#id1" title="永久链接至标题"></a></h2>
<section id="id2">
<h3><span class="section-number">36.1.1. </span>类<a class="headerlink" href="#id2" title="永久链接至标题"></a></h3>
<ul>
<li><p>在java语言中，是使用类进行编写java程序</p></li>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">类名</span><span class="p">{</span>
    <span class="c1">//书写java代码</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>在类中可以书写的内容有哪些？</p>
<ul class="simple">
<li><p>变量</p></li>
<li><p>方法</p></li>
</ul>
</li>
<li><p>在java语言中，类除了是用来定义所书写的程序外，类的另一个作用：自定义类型</p></li>
</ul>
</section>
<section id="id3">
<h3><span class="section-number">36.1.2. </span>对象<a class="headerlink" href="#id3" title="永久链接至标题"></a></h3>
<ul>
<li><p>当书写完自定义类后，需要对类进行初始化（数据类型  变量=初始化）</p></li>
<li><p>怎么对类进行初始化（初始化的动作，底层：开辟堆内存空间）</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span>类名  对象名 =  new  类名();

类名 ：  数据类型
对象名  ：  变量名
new  ：  告知JVM要开辟堆空间
类名()  ：  告知JVM要开辟空间的大小 （ 类中所书写的所有内容[变量]，进行换算，然后开辟空间 ）
           自动调用构造方法
</pre></div>
</div>
</li>
<li><p><img alt="avatar" src="../_images/classInit.png" /></p></li>
</ul>
</li>
</ul>
<p>小结 ：
类在程序中可以干什么？</p>
<ul class="simple">
<li><p>java的书写的程序内容都是类为单位</p>
<ul>
<li><p>类中书写的内容：变量、方法</p></li>
</ul>
</li>
<li><p>java中的类：  数据类型  （JVM基于这个数据类型，开辟堆空间）</p>
<ul>
<li><p>java语言提供的</p></li>
<li><p>程序员自己定义的（自定义类）</p></li>
</ul>
</li>
</ul>
<p>类中书写的内容，想要使用，怎么办?</p>
<ul class="simple">
<li><p>需要对类进行初始化（JVM在堆中开辟一个空间）</p></li>
<li><p>初始化代码： 类名  对象名 = new  类名()</p></li>
</ul>
</section>
<section id="id4">
<h3><span class="section-number">36.1.3. </span>封装<a class="headerlink" href="#id4" title="永久链接至标题"></a></h3>
<ul class="simple">
<li><p>在java语言中，在类中书写程序代码（变量、方法）</p>
<ul>
<li><p>把变量、方法封装到类中</p></li>
</ul>
</li>
<li><p>在java语言中，封装的两种代码体现：</p>
<ul>
<li><p>方法 ， 封装的是一段代码块（所封装的代码块通常是用来解决一个问题的【功能】）</p></li>
<li><p>类 ， 封装的是变量和方法</p>
<ul>
<li><p>变量，成员变量（实例变量）</p>
<ul>
<li><p>为什么叫成员？</p>
<ul>
<li><p>类需要创建对象，而通过“对象.变量”的方式去访问，称为：成员变量</p></li>
</ul>
</li>
</ul>
</li>
<li><p>方法，成员方法</p></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>// 类 
class Student{
    int age;
    
}
//在使用Student -&gt; age变量
Student stu = new Student();
stu.age = -10; //赋值为非法数据（影响了程序安全性）
//以上给age赋的值为非法数据

解决方案1：  
    定义一个变量，接收 -10
    判断变量是否合法，合法：再赋值给stu.age
    int a = -10;
    if( a &gt;= 0 ){
        stu.age = a;
    }
解决方案2： 在Studetn类中 
    第1步：不让外部直接使用age变量 （使用java中的关键字：private ）
    第2步：让外部间接把值给到一个方法，在方法中判断值是否合法
          合法： 把合法值， 赋值给 age变量

    
 java语言为了保证程序的安全性，提供了一些访问权限： 让程序中的代码使用添加了权限
 public     
 private    
    
    
    class Student{
        private int age;// 私有的变量（只能在Student类中使用age）
        
        public void setAge(int age){
             // age = age;//局部变量 = 局部变量
              //就近原则：方法中的局部变量会优先使用
             //在java中，区分局部变量和成员变量，使用：this关键字
             
             if(age&gt;=0){
                  this.age = age;
             }else{
               // 异常 
               // 日志  
             }
         }
        
        public int getAge(){
            return this.age;
        }
    } 

    Student stu = new Student();
    stu.age = -10; //不能赋值（编译：报错）
    
    //赋值合法数据：
    stu.age = 10;// 编译：报错
    stu.setAge(10);
    stu.setAge(-10);//传递的是一个非法数据

    System.out.println(&quot;年龄：&quot;+ stu.getAge() );
</pre></div>
</div>
<p>问题：想要给类中书写变量，进行赋值操作，怎么实现？</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>class Student{
    private String name;
    private int age;
    //新增变量
    private String gender;
    private String phone;
    private String stuId;
    private double height;
    .....
        
    
    public void setName(String name){
        this.name = name;
    }
    。。。。
}
//对类进行初始化
Student stu = new Student();
stu.setName(&quot;测试&quot;);
stu.setAge(10);

//当类中书写的成员变量过多时，需要使用大量的setXxx()方法，给类中的变量赋值

另一个斛决方案： java中的构造方法    
</pre></div>
</div>
</section>
<section id="id5">
<h3><span class="section-number">36.1.4. </span>构造方法<a class="headerlink" href="#id5" title="永久链接至标题"></a></h3>
<p>什么是构造方法？</p>
<p>1、和类名相同</p>
<p>2、没有返回值类型（不需要书写void关键字）</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>class Student{
     private String name;
     private int age;
     private String gender;
     private String phone;
     
    //构造方法
     public Student(){ //空参构造方法
         
     }
     
     public Student(String name,int age,...){
         //考虑到非法数据问题
         if( age &gt;= 0 ) {
             this.age = age;
         }else{
             
         }
         
          this.name=name;
          ...
              
         //开发中有不少这样写：   
           this.setAge(age);
           this.setPhone(phone);
     }  
    
    //给私有的age变量赋值
    public void setAge(int age){
          
             if(age&gt;=0){
                  this.age = age;
             }else{
               // 异常 
               // 日志  
             }
    } 
 }

构造方法对于书写程序的作用： 可以对类中的私有成员变量进行赋值
    
1、当类中有私有成员时，对类中的私有成员进行赋值操作：setXxx()
2、当类中有私有成员时，使用类的有参构造方法，对类中的私有成员进行赋值操作
    私有成员变量，只有在本类中使用（构造方法也属于本类）
</pre></div>
</div>
<p>小结：</p>
<p>针对类中的私有成员变量，有两种赋值方式：</p>
<p>1、public void setXxx(数据类型 参数)</p>
<p>2、类中的有参构造方法</p>
<blockquote>
<div><p>注意：构造方法不是由书写的程序调用的，而是由JVM自动调用</p>
<p>什么时候调用构造方法？</p>
<p>在对类进行初始化操作时： 类名  对象名 = new 类名(); //在执行当前行代码时，自动调用构造方法</p>
</div></blockquote>
<p>类：自定义类型（数据类型）</p>
<p>对象：对类进行初始化。 只有类初始化后，才可以访问类中的成员变量、成员方法</p>
<p>当变量、方法书写在类中时，就相当于把变量和方法进行了封装</p>
<p>为了程序中数据的安全性考虑，建议：把成员变量私有化</p>
<p>私有化的成员变量带来一个问题：外部程序无法访问</p>
<p>解决方案1： 提供相应的getter（获取私有成员变量的值）、setter（对私有成员变量赋值）</p>
<p>解决方案2： 使用类中的有参构造方法 （对私有成员变量赋值）</p>
</section>
<section id="id6">
<h3><span class="section-number">36.1.5. </span>继承<a class="headerlink" href="#id6" title="永久链接至标题"></a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>学生管理系统： 学生、老师
类：老师类
类：学生类
//学生类
class Student(){
    private String name;
    private int stuId;
    private int age;
    
    ....
        
    public void study(){
        ...
    }    
}
//老师类
class Teacher{
    private String name;
    private int teaId;
    private int age;
    
    ....
        
    public void teach(){
        ...
    }    
}
通过观察，Teacher类和Student类，中有不少相同的代码。
需求1：在Teacher类和Studetn类中，新增属性：教室
//学生类
class Student(){
    private String name;
    private int stuId;
    private int age;
    
    //新增
    private String classRoom;
    
    ....
        
    public void study(){
        ...
    }    
}
//老师类
class Teacher{
    private String name;
    private int teaId;
    private int age;
    
    //新增
    private String classRoom;
    
    ....
        
    public void teach(){
        ...
    }    
}
需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
再对Student类和Teacher类进行改造
    

通过刚才两个需求，发现：每次都要修改多个类中的代码（程序的修改过多）
有没有简单一些方案呢？
答： 继承    
</pre></div>
</div>
<blockquote>
<div><p>要实现继承需要什么?</p>
<p>1、要定义一个父类</p>
<p>2、要定义一个子类，子类要继承父类</p>
<p>​     继承的关键字： extends</p>
</div></blockquote>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//定义一个父类
class Person{
    private String name;
    private int teaId;
    private int age;
    ...
}
//定义一个子类
class Student extends Person{
         
    public void study(){
        ...
    }   
}
//定义一个子类
class Teacher extends Person{
    public void teach(){
        ...
    }  
}

继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量
 
    
需求1：在Teacher类和Studetn类中，新增属性：教室 
解决方案：只需要在Person类中，添加：教室   （只修改一处代码）
class Person{
    private String name;
    private int teaId;
    private int age;
    ...
        
    //新增
    private String classRoom;    
}    
    
需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
解决方案：只需要修改Person类中的代码。 int    -&gt;&lt;  long   （只修改一个类中的代码）
class Person{
    private String name;
    private long teaId;
    private int age;
    ...
        
    //新增
    private String classRoom;    
}        
</pre></div>
</div>
<p>继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量</p>
<p>2、子类只能继承一个父类（单一继承）</p>
<p>3、子类继承一个父类，父类再继承一个爷爷类，爷爷类再继承… (多层次继承 )</p>
<ul class="simple">
<li><p>子类除了可以使用父类中的非私有成员外，还可以使用爷爷类中的非私有成员</p></li>
</ul>
<p>继承的好处：提供程序中代码的复用性</p>
<blockquote>
<div><p>继承中构造方法的原理：</p>
<p>子类在初始化对象时，为了确保子类可以正常访问父类中的成员，需要先对父类进行初始化</p>
<p>子类的构造方法中，会先调用父类的构造方法</p>
<p>示例：</p>
<p>class Person{</p>
<p>public Person(){</p>
<p>}</p>
<p>}</p>
<p>class Student extends Person{</p>
<p>public Student(){</p>
<p>​        //第一行代码： super()  //调用父类中的空参构造方法  （JVM自动添加）</p>
<p>}</p>
<p>}</p>
<p>【注意】：当父类中的没有空参构造方法时，子类的构造方法中必须书写：super(参数)</p>
</div></blockquote>
</section>
<section id="thissuper">
<h3><span class="section-number">36.1.6. </span>this和super<a class="headerlink" href="#thissuper" title="永久链接至标题"></a></h3>
<p>this ： 代表当前对象</p>
<p>super： 代表父类对象</p>
<p>使用方式：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//成员变量</span>
<span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="p">;</span><span class="c1">//访问本类中的成员变量</span>
<span class="kd">super</span><span class="p">.</span><span class="na">name</span><span class="p">;</span><span class="c1">//访问父类中的成员方法</span>

<span class="c1">//成员方法</span>
<span class="k">this</span><span class="p">.</span><span class="na">method</span><span class="p">();</span><span class="c1">//访问本类中的成员方法</span>
<span class="kd">super</span><span class="p">.</span><span class="na">method</span><span class="p">();</span><span class="c1">//访问父类中的成员方法</span>

<span class="c1">//构造方法</span>
<span class="k">this</span><span class="p">();</span>   <span class="k">this</span><span class="p">(</span><span class="n">参数</span><span class="p">);</span>  <span class="c1">//访问本类中的构造方法</span>
<span class="kd">super</span><span class="p">();</span>   <span class="kd">super</span><span class="p">(</span><span class="n">参数</span><span class="p">);</span> <span class="c1">//访问父类中的构造方法</span>
</pre></div>
</div>
</section>
<section id="id7">
<h3><span class="section-number">36.1.7. </span>多态<a class="headerlink" href="#id7" title="永久链接至标题"></a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//父类
abstract class Person{
    private String name;
    private int age;
    
    ....
    
    //通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
    //抽象方法： 只定义没有方法体
    public abstract void eat();
}

class Student extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校区食堂吃饭...&quot;);
    }
} 
class Teacher extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校外吃饭...&quot;);
    }
}

 class Test{
     public static void main(String[] args){
         //创建学生对象
         Student stu = new Student();
       
         method1( stu  , &quot;zs&quot; , 20  ,   .....)
         
         //创建老师对象
         Teacher tea = new Teacher();
          
         method2(  tea ,&quot;ls&quot; ,33 , ...... )
         
     }  
     
     
     
     //大在书写程序时：当发现有重复的代码，建议都进行抽取封装：方法、类  （复用性）
     
      public static void method1( Student stu, String name , int age , ... ){
         stu.setName( name  );//因为Student继承了Person，可以使用父类中的非私有成员
         stu.setAge(  age  );
         ....
         stu.eat();  
      }
     
      public static void metho2 ( Teacher  tea , String name , int age , ...  ){
         tea.setName(  name   );
         tea.setAge(  age  );
         ....
         tea.eat(); 
      }
     
     //添加就业班
     
     //观察以上两个方法中的代码：除了对象名不同，其它都一样   (99%都是重复代码)
     针对代码，再次精进：
     
      public void method(  ?   , String name , int age , ...){
     
         ?.setName(  name   );
         ?.setAge(  age  );
         
         ....
         ?.eat();  
      }  
     
     ? 有两个类型：  Student 、 	Teacher
     Student类型和Teacher类型有什么相同？
     继承的父类是同一个    
     
     java语言提供了一种方案：多态
     多态的使用:
     1、要有继承关系
     2、子类要重写父类中的方法
     3、 父类的引用指向子类对象
         父类  父引用  =  new  子类();
     
     
     Person p1 = new Student();
     p1.setName(...)
     p1.eat()//调用的是对象中的eat方法
         
     Person p2 = new Teacher();
     p2.setName(....)
     p2.eat();
     
     
    
     
     
      public static void method(  Person p  ,  String name , int age , ...  ){
          
         p.setName(  name   );
         p.setAge(  age  );
         
         ....
         p.eat();  
      }
     
     
     
     Student stu = new Student();
     Person p = stu ; //多态
     
     method( stu ,&quot;ls&quot; , 20 ,....);
     
     
     Teacher tea = new Teacher();
       method( tea   );
     
         
 }
</pre></div>
</div>
<p><img alt="avatar" src="../_images/multiState.png" /></p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
<span class="kd">class</span> <span class="nc">Teacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



     
     
<span class="c1">//需求升学：老师需要划分为基础班老师、就业班老师</span>
<span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
     
<span class="c1">//基础班老师    </span>
<span class="kd">class</span> <span class="nc">BasicTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;吃外卖...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>     
<span class="c1">//就业班老师    </span>
<span class="kd">class</span> <span class="nc">WorkTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>      
     

 <span class="kd">class</span> <span class="nc">Test</span><span class="p">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
         <span class="c1">//创建学生对象</span>
         <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>
         
      
         <span class="c1">//创建基础老师对象</span>
         <span class="n">BasicTeacher</span> <span class="n">tea</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BasicTeacher</span><span class="p">();</span>
         
         <span class="c1">//创建就业班老师对象</span>
         <span class="n">WorkTeacher</span> <span class="n">tea2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WorkTeacher</span><span class="p">();</span>
        
      
         <span class="n">method</span><span class="p">(</span>  <span class="n">stu</span> <span class="p">,</span> <span class="s">&quot;zs&quot;</span> <span class="p">,</span> <span class="mi">20</span>  <span class="p">)</span>
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea</span> <span class="p">,</span> <span class="s">&quot;ls&quot;</span> <span class="p">,</span> <span class="mi">33</span>  <span class="p">)</span>  
             
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea2</span>  <span class="p">,</span> <span class="s">&quot;ja&quot;</span>  <span class="mi">30</span>  <span class="p">)</span>    
         
     <span class="p">}</span>  
     
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(</span>  <span class="n">Person</span>  <span class="n">p</span> <span class="p">,</span>  <span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">){</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setAge</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
         <span class="p">...</span>
         
         <span class="n">p</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>    
      <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>在使用多态时，存在 一个问题：父引用无法使用子类中特有的成员</p>
<p>解决方案： 使用向下转型 （强制类型转换）</p>
<p>格式：子类  子类对象 = (子类) 父引用</p>
<p>当在进行强制类型转换时，如果父引用指向的对象类型 和 要转换的类型不匹配，就会发生：错误</p>
<p>父引用指向的对象类型 ：  Person p = new Student();  //类型：Student</p>
<p>要转换的类型：  Teacher</p>
<p>错误代码：  Teacher tea  = (Teacher ) p;//类型转换错误</p>
<p>通常在进行向下转型时，会先进行判断：</p>
<p>if( p  instanceo  Teacher){</p>
<p>Teacher tea  = (Teacher ) p;</p>
<p>}</p>
<p>父引用  instanceof  子类类型    ：  判断父引用指向的对象类型 是否为 子类类型</p>
</div></blockquote>
<p>抽象类</p>
<ul>
<li><p>为什么有抽象类？</p>
<ul class="simple">
<li><p>当程序中书写的方法只有声明，没有方法体代码实现，该需要修饰为：abstract</p></li>
<li><p>抽象方法必须存在于抽象类中</p></li>
</ul>
</li>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="c1">//抽象方法</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>抽象类的特点：</p>
<ul class="simple">
<li><p>不能实例化（ 不能创建对象。 只能通过子类来创建对象[多态的方式] ）</p></li>
<li><p>抽象类和普通类，除了不能实例化、多了一个抽象方法外，其他和普通类都一样</p>
<ul>
<li><p>抽象类中可以书写的内容：抽象方法、构造方法、成员变量、成员方法</p></li>
<li><p>抽象类中的构造方法的作用：为了保证子类对象创建成功</p></li>
</ul>
</li>
<li><p>抽象类通常都是父类</p></li>
<li><p>抽象类中的抽象方法，子类必须重写</p></li>
</ul>
</li>
</ul>
</section>
<section id="id8">
<h3><span class="section-number">36.1.8. </span>接口<a class="headerlink" href="#id8" title="永久链接至标题"></a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>接口比类好的地方：可以多实现

接口在java中怎么使用：
1、定义一个接口
2、定义一个子类，子类实现接口，子类中并重写接口中的抽象方法
3、接口要创建对象，只使用多态的形式：  接口  父引用 = new  子类()

    
//定义接口
interface InterA{
    //接口中可书写内容是固定的
    常量、抽象方法、静态方法、默认方法
        
    public static final int NUM=10;//常量
    public abstract void method();//抽象方法
    public static void method2(){
        
    }
    public default void method3{
        
    }
}
//定义实现接口的类
class MyInter implements InterA{
    //重写抽象方法
}
//使用接口：
InterA inter = new MyInter();
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>abstract classs Person{
    String name;
    int age ;
    
   abstract  void eat();
}
class BasicStudent extends Person{
    
    public void study(){
        
    }
}
class WorkStudent extends Person implements InterA{
    public void study(){
        
    }
    //特有的功能
    public void mianshi(){
        
    }
}

class BasicTeacher extends Person{
    public void teach(){
        
    }
    
}
class WorkerTeacher extends Person implements InterA{
     public void teach(){
        
    }
     //特有的功能
    public void mianshi(){
        
    }
}

interface InterA{
    public void mianshi();
}

需求：学生都有学习方法、老师都讲课方法
    就业班学生、就业班老师都具有：面试能力
    
BasicStudent bs = new BasicStudent();
WorkTeacher tea = new WorkTeacher();

接口：
    1、当有部分类中的功能是相同时，可以把这部分相同的功能，抽取出来，封装到：接口

 
要执行就业班老师和就业班学生的：面试功能
WorkTeacher tea = new WorkTeacher();
WorkStudenet stu = new WorkStudent();
tea.mianshi();
stu.mianshi();


method( tea );
method(  stu )


public void method( InterA inter ){
    inter.mianshi()
}
</pre></div>
</div>
<p>在企业开发中，大量使用接口。</p>
<blockquote>
<div><p>为什么？</p>
<p>通常在开发前期，会针对开发中的功能进行制定（需求分析）</p>
<p>前期：制定功能（没有功能代码）</p>
<p>​           使用抽象方法</p>
<p>问题：抽象方法是定义哪里？  抽象类  or 接口？</p>
<p>答案： 接口  （接口可以多实现）</p>
<p>程序开发：接口</p>
<p>public interface 接口A｛</p>
<p>//功能1：</p>
<p>​                public  boolean  login(String name,Strng passwd);</p>
<p>//功能2：</p>
<p>​                 public  boolean  changePasswd(String name , String oldPasswd);</p>
<p>}</p>
<p>public interface 接口B｛</p>
<p>…..</p>
<p>｝</p>
</div></blockquote>
<p>进入到开发阶段：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//程序员01号
class UserImpl implements IUser｛
   //重写抽象方法 
    具体方法中的功能代码
｝
class OrderImpl implements  IOrder{
    
}
class ManagerImpl  implements IManager{
    
}
    
=======================================================    
    
    
//程序员02号    
class 类{
    
    public void method(){
        
        //让用户先登录
        IUser user = new UserImpl();//多态  接口 
        user.login(&quot;&quot;,&quot;&quot;)
        
    }
}    
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h2><span class="section-number">36.2. </span>面向对象<a class="headerlink" href="#id9" title="永久链接至标题"></a></h2>
<section id="id10">
<h3><span class="section-number">36.2.1. </span>包<a class="headerlink" href="#id10" title="永久链接至标题"></a></h3>
<p>在学习java基础时，使用过Scanner。 要使用Scanner需要导入：import java.util.Scanner</p>
<p>包是什么？</p>
<ul class="simple">
<li><p>文件夹</p>
<ul>
<li><p>可以帮我们管理文件</p></li>
</ul>
</li>
</ul>
<p>包能做什么？</p>
<ul class="simple">
<li><p>在开发中，程序员会书写很多的类，这些类有一些可能会出现重名</p></li>
<li><p>在开发中，所开发的项目中，会包含不同功能模块：商品、订单、用户、….</p>
<ul>
<li><p>针对不同的功能模块，书写不同的java程序</p></li>
</ul>
</li>
<li><p>包的作用：可以帮我们管理.java文件</p>
<ul>
<li><p>避免重名</p></li>
<li><p>实现不同功能的类，可以存放在不同的功能模块下</p></li>
</ul>
</li>
</ul>
<p>怎么使用包？</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>创建包：package
    把不现的.java文件存放在不同的包下
    
导入包：import    
    当需要使用别人开发好的功能时，需要先找到功能所属的类，然后使用import导入这个类
    创建类对象，使用对象.功能()   
</pre></div>
</div>
<p>package使用注意事项：</p>
<p>1、package必须书写在java程序的首行</p>
<p>2、一个.java文件夹中，只能书写 一个package</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima</span><span class="p">;</span>  <span class="c1">//只能有一个package</span>
<span class="c1">//package com.itcast;//报错</span>
    

<span class="kd">class</span> <span class="nc">Itcast</span><span class="p">{</span>
    
<span class="p">}</span>    
</pre></div>
</div>
<p>包的命名规则：</p>
<p>1、全部小写字母</p>
<p>2、包名通常使用域名，倒着写的方式（企业中的标准）</p>
<p>3、通常创建包名，都是有多个包，包之间使用.连接</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima.hw.demo1</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>在书写程序时，需要引用别人写好的类中功能，需要：导包</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima</span><span class="p">;</span><span class="c1">// Test类归属的包</span>

<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="p">;</span><span class="c1">//导包</span>

<span class="kd">class</span> <span class="nc">Test</span><span class="p">{</span>
    <span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="c1">///要使用别人写的功能，要导入</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在书写 程序时，有两种导入包的方式：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>第一种：(不推荐)
    java.util.Scanner  sc = new java.util.Scanner(System.in);//书写类名时直接把包导入

    java.util.Scanner  sc2 = new java.util.Scanner(System.in);

    java.util.Scanner  sc3 = new java.util.Scanner(System.in);

第二种：
    import java.util.Scanner;

    Scanner sc = new Scanner(System.in);

    Scanner sc2 = new Scanner(System.in);
 
    Scanner sc3 = new Scanner(System.in);
</pre></div>
</div>
</section>
<section id="id11">
<h3><span class="section-number">36.2.2. </span>访问修饰符<a class="headerlink" href="#id11" title="永久链接至标题"></a></h3>
<p>在java中为了程序的安全性，java语言提供了4种用来访问成员的权限</p>
<p>1、public</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="c1">//公开的</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">study</span><span class="p">(){</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>2、private</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
   <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//私有的。只能本类使用</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>3、默认       什么都不书写</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//默认的访问修饰符</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>4、protected</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">pubilc</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//受保护的（子类专用）</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>访问修饰符号的访问范围</strong></p>
</div></blockquote>
<p>| 修饰符号 (从小到大排列) | 本类    | 同一个包下的类(非子类) | 同一个包下的子类 | 不同包下的类（非子类） | 不同包下的子类 |
| ———————– | ——- | ———————- | —————- | ———————- | ————– |
| private                 | <strong>YES</strong> | NO                     | NO               | NO                     | NO             |
| 默认                    | <strong>YES</strong> | <strong>YES</strong>                | <strong>YES</strong>          | NO                     | NO             |
| protected               | <strong>YES</strong> | NO                     | <strong>YES</strong>          | NO                     | <strong>YES</strong>        |
| public                  | <strong>YES</strong> | <strong>YES</strong>                | <strong>YES</strong>          | <strong>YES</strong>                | <strong>YES</strong>        |</p>
</li>
</ul>
</section>
</section>
<section id="api">
<h2><span class="section-number">36.3. </span>常用API<a class="headerlink" href="#api" title="永久链接至标题"></a></h2>
<section id="object">
<h3><span class="section-number">36.3.1. </span>Object类<a class="headerlink" href="#object" title="永久链接至标题"></a></h3>
<p>Object类的基本认知：</p>
<p>1、java.lang.Object</p>
<p>2、Obejct类是java语言中的鼻祖类（最顶层的父类）</p>
<p>3、java中程序中所书写的类以及所使用的类，都要继承Object</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">class</span> <span class="nc">Father</span><span class="p">{</span><span class="c1">//书写时没有书写继承 JVM自动会添加：class Father extends Object</span>

<span class="p">}</span>
<span class="c1">//子类 </span>
<span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="n">Father</span><span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>可以使用Object类中的成员方法(功能)</p></li>
</ul>
<p>Object类中的成员方法 ：</p>
<ul>
<li><p>String   toString()</p>
<ul class="simple">
<li><p>功能：返回字符串格式的对象</p></li>
</ul>
</li>
<li><p>boolean  equals(Object  obj)</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>

<span class="n">equals</span><span class="p">(</span>  <span class="n">stu</span>  <span class="p">)</span>   <span class="c1">//   Object obj = stu;</span>
</pre></div>
</div>
</li>
<li><p>功能：比较两个对象是否相等</p></li>
</ul>
</li>
</ul>
</section>
<section id="string">
<h3><span class="section-number">36.3.2. </span>String类<a class="headerlink" href="#string" title="永久链接至标题"></a></h3>
<p>之前一直在使用：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>String到底是什么 东西？ 它是一种数据类型呢？还是一个类呢？</p>
<p>String是一个类。不属于java的基本数据类型，属于引用类型</p>
<p>在java语言中，只要书写了<code class="docutils literal notranslate"><span class="pre">&quot;....&quot;</span></code>,默认就是一个字符串对象：String类的对象</p>
<p>简单理解：在java中只要被英文的双引号包含的内容，默认就是一个String对象</p>
<p>String类的特点：</p>
<p>1、被英文双引号包含的内容，都是一个String类的实例</p>
<p>2、String中存储的字符串，不能被修改（不能对原值进行修改）</p>
<p>String类中的常用方法 ：</p>
<ul class="simple">
<li><p>boolean  equals(Object obj)  :     String类重写了Object类中equals方法。</p>
<ul>
<li><p>String类中的equals方法 ，功能：  比较两个字符串的内容是否相等，区分大小字母</p></li>
<li><p>在java语言中：</p>
<ul>
<li><p>比较字符串的地址，使用 ： ==</p></li>
<li><p>比较字符串内容，使用： equals() 方法</p></li>
</ul>
</li>
</ul>
</li>
<li><p>boolean  equalsIgnoreCase(String  str)  ：   比较两个字符串是否相等，忽略大小写</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="%5BJava%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html" class="btn btn-neutral float-left" title="35. [Java]设计模式六大原则" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="%5BJava%5D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" class="btn btn-neutral float-right" title="37. [Java]OOP防脱发指南" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2020-2022, roohom.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>